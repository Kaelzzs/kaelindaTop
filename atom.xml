<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[kaelinda]]></title>
  <link href="http://blog.csdn.net/atom.xml" rel="self"/>
  <link href="http://blog.csdn.net/"/>
  <updated>2017-12-22T14:55:02+08:00</updated>
  <id>http://blog.csdn.net/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[学习资源网址]]></title>
    <link href="http://blog.csdn.net/15139059079620.html"/>
    <updated>2017-12-22T09:25:07+08:00</updated>
    <id>http://blog.csdn.net/15139059079620.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">技术学习资源</h2>

<h3 id="toc_1">sublime学习资源</h3>

<ul>
<li><a href="http://www.jianshu.com/p/aa30cc25c91b">Sublime 入门+进阶</a>：<code>http://www.jianshu.com/p/aa30cc25c91b</code></li>
<li><a href="http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/">sublime全解</a>: <code>http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/</code></li>
<li><a href="https://dribbble.com/">Sublime 图标下载</a>: <code>https://dribbble.com/</code></li>
</ul>

<h3 id="toc_2">MarkDown学习资源</h3>

<span id="more"></span><!-- more -->

<ul>
<li><a href="http://wowubuntu.com/markdown/">Wow!Ubuntu</a>: <code>http://wowubuntu.com/markdown/</code></li>
<li><a href="http://blog.csdn.net/witnessai1/article/details/52551362">Markdown 语法手册</a>: <code>http://blog.csdn.net/witnessai1/article/details/52551362</code></li>
<li><a href="https://sanwen8.cn/p/670KuHA.html"> 精致Markdown【语法篇】</a>:<code>https://sanwen8.cn/p/670KuHA.html</code></li>
<li><a href="https://segmentfault.com/markdown">Markdown编辑器语法指南 - SegmentFault</a> : <code>https://segmentfault.com/markdown</code><br/></li>
<li><a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/">sublime + Markdown</a>: <code>http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/</code></li>
</ul>

<h3 id="toc_3">Shell脚本学习资源</h3>

<ul>
<li><a href="http://www.runoob.com/linux/linux-shell.html">shell教程</a>: <code>http://www.runoob.com/linux/linux-shell.html</code></li>
<li><a href="http://www.cnblogs.com/Lynn-Zhang/p/5758287.html">shell脚本入门</a>: <code>http://www.cnblogs.com/Lynn-Zhang/p/5758287.html</code></li>
</ul>

<h3 id="toc_4">Git命令学习资源</h3>

<ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">Git命令清单--阮一峰</a>: <code>http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</code></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程--廖雪峰</a>: <code>http://www.liaoxuefeng.com</code></li>
<li><a href="https://segmentfault.com/a/1190000009491296">本地项目推送到远程git仓库</a>: <code>https://segmentfault.com/a/1190000009491296</code></li>
<li><a href="https://segmentfault.com/a/1190000009516449">Git使用教程--segmenfault</a>: <code>https://segmentfault.com/a/1190000009516449</code></li>
</ul>

<h3 id="toc_5">Mac终端命令</h3>

<ul>
<li><a href="http://www.jianshu.com/p/3291de46f3ff">终端命令大全:简书</a>：<code>http://www.jianshu.com/p/3291de46f3ff</code></li>
<li><a href="http://blog.csdn.net/u014220518/article/details/53282785">Mac终端命令总结</a>： <code>http://blog.csdn.net/u014220518/article/details/53282785</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rect-Native 之 Promise 深入浅出从入门到精通]]></title>
    <link href="http://blog.csdn.net/15139057022845.html"/>
    <updated>2017-12-22T09:21:42+08:00</updated>
    <id>http://blog.csdn.net/15139057022845.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">概念理解</h2>

<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fhp9dw6vxpj307406ewek.jpg" alt="icon" title="React icon"/></p>

<blockquote>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h3 id="toc_1">Promise 状态</h3>

<ul>
<li>Pending 进行中</li>
<li>Resolved 已完成 又称Fulfilled</li>
<li>Rejected 已失败</li>
</ul>

<h3 id="toc_2">Promise 特点</h3>

<ul>
<li>对象的状态不受外部因素影响。Promise对象代表的是一个异步操作，只有异步操作的结果能决定Promise的状态，任何其他操作都不能决定其状态。</li>
<li>一旦Promise有了结果状态就不会再变。<code>Pending==&gt;Resolved</code>,或者<code>Pending==&gt;Rejected</code></li>
</ul>

<h3 id="toc_3">Promise 缺点</h3>

<p>Promise的缺点是：一旦建立就会立即执行，无法中途取消。</p>

<h2 id="toc_4">Promise 基本用法</h2>

<pre><code class="language-JavaScript">var promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
</code></pre>

<p>Promise对象接受一个参数，这个参数是一个函数体。<br/>
这个函数有两个参数：一个是resolve，一个是reject。这两个参数是Promise自动提供，不需要使用者传值。<br/>
* resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 Pending 变为 Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去<br/>
* reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 Pending 变为 Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。<br/>
  Promise实例生成后，可以用then分别指定Resolved和Rejected的回调函数。<br/>
<code>JavaScript<br/>
promise.then(function(value) {<br/>
  // success<br/>
}, function(error) {<br/>
  // failure<br/>
});<br/>
</code><br/>
then方法会接受两个参数：<br/>
* 第一个函数，Promise状态变更为Resolved时调用。<br/>
* 第二个函数，Promise状态变为Rejected时调用。可选的，可以不提供。</p>

<p>下面是异步加载图片的例子：<br/>
```JavaScript<br/>
function loadImageAsync(url) {<br/>
  return new Promise(function(resolve, reject) {<br/>
    var image = new Image();</p>

<pre><code>image.onload = function() {
  resolve(image);
};

image.onerror = function() {
  reject(new Error(&#39;Could not load image at &#39; + url));
};

image.src = url;
</code></pre>

<p>});<br/>
}<br/>
<code><br/>
下面是Promise实现的Ajax操作的例子：<br/>
</code>JavaScript<br/>
var getJSON = function(url) {<br/>
  var promise = new Promise(function(resolve, reject){<br/>
    var client = new XMLHttpRequest();<br/>
    client.open(&quot;GET&quot;, url);<br/>
    client.onreadystatechange = handler;<br/>
    client.responseType = &quot;json&quot;;<br/>
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);<br/>
    client.send();<br/>
    function handler() {<br/>
      if (this.readyState !== 4) {<br/>
        return;<br/>
      }<br/>
      if (this.status === 200) {<br/>
        resolve(this.response);<br/>
      } else {<br/>
        reject(new Error(this.statusText));<br/>
      }<br/>
    };<br/>
  });</p>

<p>return promise;<br/>
};</p>

<p>getJSON(&quot;/posts.json&quot;).then(function(json) {<br/>
  console.log(&#39;Contents: &#39; + json);<br/>
}, function(error) {<br/>
  console.error(&#39;出错了&#39;, error);<br/>
});<br/>
```<br/>
<strong>注意：在getJSON内部，resolve函数和reject函数调用时，都带有参数！！</strong><br/><br/>
    如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。<br/>
* reject函数的参数通常是Error对象的实例，表示抛出的错误<br/>
* resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作</p>

<pre><code class="language-JavaScript">var p1 = new Promise(function (resolve, reject) {
  // ...
});

var p2 = new Promise(function (resolve, reject) {
  // ...
  resolve(p1);
})
</code></pre>

<p>上面👆，<code>p1</code>、<code>p2</code> 都是Promise，但是<code>p2</code>的resolve把<code>p1</code>作为返回值参数传出去了，即一个异步操作的返回结果是另一个异步操作。（类似于iOS开发中的自动布局库 <code>Masonry</code>,可以无限点语法取到对象）。<br/><br/>
<strong>注意：此时，p1的状态会传递p2.如果p1是Pending状态,那么p2会等待p1的结果。如果p1是Reject或者Resolve状态，那么p2的回调函数将会立即执行。</strong></p>

<p><strong>再看:</strong><br/>
```JavaScript<br/>
var p1 = new Promise(function (resolve, reject) {<br/>
  setTimeout(() =&gt; reject(new Error(&#39;fail&#39;)), 3000)<br/>
})</p>

<p>var p2 = new Promise(function (resolve, reject) {<br/>
  setTimeout(() =&gt; resolve(p1), 1000)<br/>
})</p>

<p>p2.then(result =&gt; console.log(result))<br/>
  .catch(error =&gt; console.log(error))<br/>
// Error: fail<br/>
```</p>

<ol>
<li><code>p1</code>会在3秒后抛出error。<br/></li>
<li><code>p2</code>会在1秒后改变状态。Resolv的返回值是<code>p1</code>.<br/></li>
<li>由于<code>p2</code>的返回值是一个Promise，导致<code>p2</code>自己的状态无效了，此时<code>p2</code>的状态取决于<code>p1</code>.<br/></li>
<li>所以，后面的then语句，都变成针对p1的了。<br/></li>
<li>又过了<code>2秒</code>，<code>p1</code>变为<code>reject</code>，导致触发<code>catch</code>方法。<br/></li>
</ol>

<h2 id="toc_5">3. Promise.prototype.then()</h2>

<p><strong>then方法是定义在原型对象Promise.prototype上的。</strong><br/>
作用：为Promise对象添加状态改变时的回调函数。第一个是Resolved，第二个是Rejected。<br/>
then方法返回的是一个新的Promise对象，不是之前的实例。因此 then方法后面还可以再写一个then方法,即链式调用。</p>

<pre><code class="language-JavaScript">getJSON(&quot;/posts.json&quot;).then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
</code></pre>

<p>第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>

<pre><code class="language-JavaScript">getJSON(&quot;/post/1.json&quot;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function funcA(comments) {
  console.log(&quot;Resolved: &quot;, comments);
}, function funcB(err){
  console.log(&quot;Rejected: &quot;, err);
});
</code></pre>

<p>第一个then函数返回的是一个新的Promise对象。于是才能继续调用then方法。<br/>
第二个then方法指定的回调函数，就会等待这个Promise对象状态发生变化，resolv会调用funcA,reject会调用funcB.</p>

<p>下面👇是箭头函数的实现，会更简洁：<br/>
<code>JavaScript<br/>
getJSON(&quot;/post/1.json&quot;).then(<br/>
  post =&gt; getJSON(post.commentURL)<br/>
).then(<br/>
  comments =&gt; console.log(&quot;Resolved: &quot;, comments),<br/>
  err =&gt; console.log(&quot;Rejected: &quot;, err)<br/>
);<br/>
</code></p>

<h2 id="toc_6">4. Promise.prototype.catch()</h2>

<h3 id="toc_7">Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数</h3>

<p><strong>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数.</strong><br/><br/>
<code>JavaScript<br/>
getJSON(&#39;/posts.json&#39;).then(function(posts) {<br/>
  // ...<br/>
}).catch(function(error) {<br/>
  // 处理 getJSON 和 前一个回调函数运行时发生的错误<br/>
  console.log(&#39;发生错误！&#39;, error);<br/>
});<br/>
</code></p>

<p>getJSON()方法返回的是一个Promise对象。如果resolv，会调用then方法；如果reject则会调用catch方法。</p>

<h3 id="toc_8">then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获</h3>

<p><strong>另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获</strong>   </p>

<pre><code class="language-JavaScript">p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))
  .catch((err) =&gt; console.log(&#39;rejected&#39;, err));

// 等同于
p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
</code></pre>

<pre><code>var promise = new Promise(function(resolve, reject) {
  throw new Error(&#39;test&#39;);
});
promise.catch(function(error) {
  console.log(error);
});
// Error: test
</code></pre>

<p>Promise对象Resolved，但是Resolved指定的方法跑出错误。<br/>
Promise对象catch方法能捕获跑出的error。</p>

<h3 id="toc_9">reject方法等同于抛出错误</h3>

<p>上面的写法跟下面的两种写法是一样的：<br/>
```<br/>
// 写法一<br/>
var promise = new Promise(function(resolve, reject) {<br/>
  try {<br/>
    throw new Error(&#39;test&#39;);<br/>
  } catch(e) {<br/>
    reject(e);<br/>
  }<br/>
});<br/>
promise.catch(function(error) {<br/>
  console.log(error);<br/>
});</p>

<p>// 写法二<br/>
var promise = new Promise(function(resolve, reject) {<br/>
  reject(new Error(&#39;test&#39;));<br/>
});<br/>
promise.catch(function(error) {<br/>
  console.log(error);<br/>
});<br/>
```</p>

<p><strong>由此可见：reject方法等同于抛出错误。</strong></p>

<h3 id="toc_10">resolve之后在抛出错误，catch是捕获不到的不到的。</h3>

<pre><code>var promise = new Promise(function(resolve, reject) {
  resolve(&#39;ok&#39;);
  throw new Error(&#39;test&#39;);
});
promise
  .then(function(value) { console.log(value) })
  .catch(function(error) { console.log(error) });
// ok
</code></pre>

<p><strong>resolve之后在抛出错误，catch是捕获不到的不到的。</strong></p>

<h3 id="toc_11">Promise 对象的错误具有“冒泡”性质</h3>

<p><strong>Promise 对象的错误具有“冒泡”性质,会一直向后传递，直到被捕获为止 ------ 错误总是会被下一个catch语句捕获</strong></p>

<blockquote>
<p>举个栗子：就像是Y染色体上受环境触发的遗传疾病，会不断的遗传给男性后代，任意一个男性都会被特殊的环境触发。</p>
</blockquote>

<pre><code>getJSON(&#39;/post/1.json&#39;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
</code></pre>

<p>上述代码中有三个Promise，第一个由getJSON产生，后两个由then产生。他们之中的任何一个抛出错误，都会被catch捕获。</p>

<p>一般来讲，尽量不要定义Promise的reject状态的回调函数，最好总是使用catch函数，因为catch函数不仅能捕获到reject状态，还能捕获到resolve状态指定方法下抛出的异常。</p>

<h3 id="toc_12">Promise对象抛出的错误不会传递到外层代码</h3>

<p>如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应，这一点上跟传统的try/catch代码块不同的。</p>

<pre><code>process.on(&#39;unhandledRejection&#39;, function (err, p) {
  console.error(err.stack)
});
</code></pre>

<p>时间的监听函数‘unhandledRejection’,有两个参数：<br/>
第一个是错误对象<br/>
第二个是报错的Promise实例</p>

<p>catch方法返回的也是一个Promise实例，所以后面还是可以无限的调用then方法。<br/>
如果catch函数在几个then中间，二执行过程中都没有reject状态，那么会跳过这个中间的catch方法。</p>

<h3 id="toc_13">catch方法中也能抛出错误</h3>

<pre><code>var someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};

someAsyncThing().then(function() {
  return someOtherAsyncThing();
}).catch(function(error) {
  console.log(&#39;oh no&#39;, error);
  // 下面一行会报错，因为y没有声明
  y + 2;
}).then(function() {
  console.log(&#39;carry on&#39;);
});
// oh no [ReferenceError: x is not defined]
</code></pre>

<p>如上：catch方法指定的函数依旧是可以抛出Error的，但是因为后面没有继续跟进catch方法，所以并没有被捕获。</p>

<h2 id="toc_14">5. Promise.all()</h2>

<p><strong>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</strong></p>

<pre><code>var p = Promise.all([p1, p2, p3]);
</code></pre>

<p>Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。<br/>
（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>

<p>p的状态由p1、p2、p3决定，分成两种情况:<br/>
* 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数<br/>
* 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数</p>

<p><strong>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</strong></p>

<pre><code>const p1 = new Promise((resolve, reject) =&gt; {
  resolve(&#39;hello&#39;);
})
.then(result =&gt; result)
.catch(e =&gt; e);

const p2 = new Promise((resolve, reject) =&gt; {
  throw new Error(&#39;报错了&#39;);
})
.then(result =&gt; result)
.catch(e =&gt; e);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
</code></pre>

<p>p1会resolved，p2首先会rejected.<br/>
p2有自己的catch方法，并且执行了，那么就会返回一个新的Promise，并且这个Promise的状态会变成Resolved。<br/>
所以：Promise.all()的catch方法并不能捕获到这个error。<br/>
p2没有自己的catch方法，所以会调用Promise.all()的catch方法。</p>

<h2 id="toc_15">6. Promise.race()</h2>

<p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。<br/>
<code><br/>
var p = Promise.race([p1, p2, p3]);<br/>
</code><br/>
p1/p2/p3中只要有一个率先改变状态，p的状态就会随着改变。那个率先改变状态的实例的返回值，就会传递给p的回调函数。<br/>
<code><br/>
const p = Promise.race([<br/>
  fetch(&#39;/resource-that-may-take-a-while&#39;),<br/>
  new Promise(function (resolve, reject) {<br/>
    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)<br/>
  })<br/>
]);<br/>
p.then(response =&gt; console.log(response));<br/>
p.catch(error =&gt; console.log(error));<br/>
</code></p>

<p>5秒内无法返回请求结果，变量p的状态就会变为reject。这也算是竞速的一种应用场景。</p>

<h2 id="toc_16">7. Promise.resolve()</h2>

<p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用.</p>

<pre><code>var jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));
</code></pre>

<p>等价于下面的说法：<br/>
<code><br/>
Promise.resolve(&#39;foo&#39;)<br/>
// 等价于<br/>
new Promise(resolve =&gt; resolve(&#39;foo&#39;))<br/>
</code></p>

<p>Promise 的第一个参数是一个箭头函数，函数的传入参数是resolve（函数），函数体就是调用传入的函数resolve，resolve调用的时候，也需要一个参数，此时这个参数就是咱们需要转变成Promise对象的那个参数。</p>

<p>Promise.resolve的参数有四种情况：<br/>
1. 参数是一个Promise实例<br/>
2. 参数是一个thenable对象（有then方法的实例）<br/>
3. 参数是不具备then方法d的对象应该<br/>
4. 不带参数，返回一个Resolved的返回状态。</p>

<h2 id="toc_17">8、Promise.reject()   同上</h2>

<h2 id="toc_18">9、两个常用附加方法</h2>

<h3 id="toc_19">done()</h3>

<p>Promise的错误并不会冒泡到全局，所以我们可以提供一个done方法总是处于会吊链的尾端。<br/>
<code><br/>
asyncFunc()<br/>
  .then(f1)<br/>
  .catch(r1)<br/>
  .then(f2)<br/>
  .done();<br/>
</code></p>

<p>done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出.</p>

<h3 id="toc_20">finally()</h3>

<p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>

<pre><code>Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  =&gt; P.resolve(callback()).then(() =&gt; value),
    reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })
  );
};
</code></pre>

<h3 id="toc_21">Promis.try()</h3>

<pre><code>try {
  database.users.get({id: userId})
  .then(...)
  .catch(...)
} catch (e) {
  // ...
}
</code></pre>

<pre><code>Promise.try(database.users.get({id: userId}))
  .then(...)
  .catch(...)
</code></pre>

<p>Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 笔记（Array）]]></title>
    <link href="http://blog.csdn.net/15137645005542.html"/>
    <updated>2017-12-20T18:08:20+08:00</updated>
    <id>http://blog.csdn.net/15137645005542.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">array</h2>

<ol>
<li><p>Array.from<br/>
将类似数组的对象（array-like object）和可遍历（iterable）的对象 转换为数组。</p>

<ul>
<li>类数组：有 length属性的对象</li>
<li>可遍历：包含Set Map.</li>
</ul></li>
<li><p>Array.of<br/>
该方法用于将一组值，转换为数组。</p></li>
</ol>

<span id="more"></span><!-- more -->

<ol>
<li><p>copyWithin<br/>
在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员）。</p>

<ul>
<li>      target（必需）：从该位置开始替换数据。</li>
<li>      start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>      end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul></li>
<li><p>数组实例的find()和findIndex()<br/>
用于找出第一个符合条件的数组成员。<br/>
用于找出第一个符合条件的数组成员的位置。</p></li>
<li><p>fill<br/>
方法使用给定值，填充一个数组。<br/>
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)<br/>
// [&#39;a&#39;, 7, &#39;c&#39;];// 左闭右开</p></li>
<li><p>数组实例的entries()，keys()和values()<br/>
keys()是对键名的遍历<br/>
values()是对键值的遍历<br/>
entries()是对键值对的遍历</p></li>
<li><p>Array.prototype.includes方法<br/>
返回一个布尔值，表示某个数组是否包含给定的值。<br/>
[1, 2, 3].includes(3, -1); // true<br/>
3:将要搜索的item<br/>
-1：搜索的起始位置  </p></li>
<li><p>数组的空位<br/>
数组的空位指，数组的某一个位置没有任何值。</p></li>
</ol>

<p>空位不是undefined，undefined是有值的。<br/>
空位是没有任何值。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 笔记（常量&&变量）]]></title>
    <link href="http://blog.csdn.net/15137627946753.html"/>
    <updated>2017-12-20T17:39:54+08:00</updated>
    <id>http://blog.csdn.net/15137627946753.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">变量&amp;&amp;常量</h2>

<h3 id="toc_1">新特性</h3>

<ol>
<li><p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p></li>
<li><p>变量提升：var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined；为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p></li>
<li><p>暂时性死区：在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”；</p></li>
</ol>

<span id="more"></span><!-- more -->

<pre><code>```
var tmp = 123;

if (true) {
tmp = &#39;abc&#39;; // ReferenceError  死区
let tmp;
}
```

&gt; let不允许在相同作用域内，重复声明同一个变量。
</code></pre>

<h3 id="toc_2">块级作用域</h3>

<ul>
<li>内层作用域可以定义外层作用域的同名变量。</li>
<li>内部作用域  重名变量  不会影响，</li>
<li>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数（ES5不允许）。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>函数声明还会提升到所在的块级作用域的头部。</li>
</ul>

<blockquote>
<p>块级作用域是一个语句，将多个操作封装在一起，没有返回值。<br/>
在块级作用域之前加上do，使它变为do表达式。会得到整个块级作用域的返回值</p>
</blockquote>

<h3 id="toc_3">const:</h3>

<ul>
<li>const声明一个只读的常量。一旦声明，常量的值就不能改变。</li>
<li>const一旦声明变量，就必须立即初始化，不能留到以后赋值。</li>
<li>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</li>
<li><p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p></li>
<li><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动</p></li>
<li><p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p></li>
<li><p>如果真的想将对象冻结，应该使用Object.freeze方法</p></li>
</ul>

<pre><code class="language-JavaScript">//冻结对象属性：
var constantize = (obj) =&gt; {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) =&gt; {
    if ( typeof obj[key] === &#39;object&#39; ) {
      constantize( obj[key] );
    }
  });
};
</code></pre>

<h3 id="toc_4">变量声明：</h3>

<blockquote>
<p>ES5 只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法</p>
</blockquote>

<ul>
<li>顶层对象的属性：
ES5中 顶层对象的属性  和 全局变量是一回事儿；全局变量是静态创建，而对象属性是动态创建的；不合理。
ES6中 var function 声明的全局变量 依然是顶层对象的属性；但是 let const class声明的全局变量 不属于顶层对象的属性。</li>
</ul>

<!-- more -->

<ul>
<li>全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。</li>
<li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</li>
<li>不管是严格模式，还是普通模式，new Function(&#39;return this&#39;)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。</li>
</ul>

<pre><code class="language-JavaScript">// 方法一
(typeof window !== &#39;undefined&#39;
   ? window
   : (typeof process === &#39;object&#39; &amp;&amp;
      typeof require === &#39;function&#39; &amp;&amp;
      typeof global === &#39;object&#39;)
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== &#39;undefined&#39;) { return self; }
  if (typeof window !== &#39;undefined&#39;) { return window; }
  if (typeof global !== &#39;undefined&#39;) { return global; }
  throw new Error(&#39;unable to locate global object&#39;);
};
</code></pre>

<p>// ES6模块的写法<br/>
import getGlobal from &#39;system.global&#39;;<br/>
const global = getGlobal();</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6笔记（解构赋值）]]></title>
    <link href="http://blog.csdn.net/15137621729153.html"/>
    <updated>2017-12-20T17:29:32+08:00</updated>
    <id>http://blog.csdn.net/15137621729153.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">解构赋值</h2>

<h3 id="toc_1">变量的解构：</h3>

<ul>
<li>解构赋值允许指定默认值。</li>
<li>解构赋值必须保证赋值方  被赋值方类型一直  但Item允许有遗漏或者多出。</li>
<li>默认值可以引用解构赋值的其他变量，但该变量必须已经声明</li>
</ul>

<pre><code>let [x = 1, y = x] = [];     // x=1; y=1
let [x = y, y = 1] = [];     // ReferenceError
</code></pre>

<span id="more"></span><!-- more -->

<h3 id="toc_2">对象的 解构赋值：</h3>

<ul>
<li>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；</li>
<li><p>而对象的属性没有次序，变量必须与属性同名，才能取到正确的值<br/>
（数据库、序列化）</p></li>
<li><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者；前者是key,后者才是变量！</p>

<blockquote>
<p>注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。</p>
</blockquote></li>
</ul>

<h3 id="toc_3">字符串的解构赋值</h3>

<blockquote>
<p>字符串也可以解构赋值。<br/>
这是因为此时，字符串被转换成了一个类似数组的对象<br/>
类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
</blockquote>

<pre><code class="language-JavaScript">let {length : len} = &#39;hello&#39;;
len // 5

let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true

let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
</code></pre>

<p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。<br/>
undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>

<ul>
<li>不能使用圆括号的情况

<ul>
<li>变量声明语句中，不能带有圆括号</li>
<li>函数参数中，模式不能带有圆括号。</li>
<li>赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中</li>
</ul></li>
<li>可以使用圆括号的情况只有一种：赋值语句的<strong>非模式部分</strong>，可以使用圆括号。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS打包上架素材准备概要说明]]></title>
    <link href="http://blog.csdn.net/15130872092436.html"/>
    <updated>2017-12-12T22:00:09+08:00</updated>
    <id>http://blog.csdn.net/15130872092436.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">开发者打包</h2>

<h3 id="toc_1">Xcode配置</h3>

<p><em>Xcode8 旧标准</em></p>

<ul>
<li><p>Xcode8 icon iPhone</p>

<ul>
<li><code>icon-29.png        29*29</code></li>
<li><code>icon-29@2x.png     58*58</code></li>
<li><code>icon-29@3x.png     87*87</code></li>
<li><code>icon-40@2x.png     80*80</code></li>
<li><code>icon-40@3x.png     120*120</code></li>
<li><code>icon-57.png        57*57</code></li>
<li><code>icon-57@2x.png     114*114</code></li>
<li><code>iocn-60@2x.png     120*120</code></li>
<li><code>icon-60@3x.png     180*180</code></li>
<li><code>icon-20@2x.png     40*40</code></li>
<li><code>icon-20@3x.png     60*60</code><br/></li>
</ul></li>
<li><p>Xcode8 LaunchImage：</p>

<ul>
<li><code>414*736 @3x    1242*2208</code></li>
<li><code>736*414  @3x    2208*1242</code></li>
<li><code>375*667 @2x    750*1334</code></li>
<li><code>320*568 @2x    640*1136</code></li>
<li><code>320*480 @2x    640*960</code></li>
<li><code>320*480 @1x    320*480</code></li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->

<p><em>Xcode9 新标准</em></p>

<blockquote>
<p><em>产品和美工同学组要注意下了</em><br/>
@2x 代表2倍图 <br/>
@3x代表三倍图<br/>
pt代表的是物理像素（或者自然像素）</p>
</blockquote>

<ul>
<li>Xcode9 icon :

<ul>
<li>iPhone 8张icon

<ul>
<li><code>20pt  @2x  @3x</code></li>
<li><code>29pt  @2x  @3x</code></li>
<li><code>40pt  @2x  @3x</code></li>
<li><code>60pt  @2x  @3x</code></li>
</ul></li>
<li>Xcode9 ipad

<ul>
<li><code>20pt  @1x  @2x</code></li>
<li><code>29pt  @1x  @2x</code></li>
<li><code>40pt  @1x  @2x</code></li>
<li><code>76pt  @1x  @2x</code></li>
<li><code>83.5pt @2x</code></li>
</ul></li>
<li>AppStore  <code>1024*1024 @1x</code></li>
<li>Xcode9 LaunchImage：

<ul>
<li><code>375*812 @3x    1125*2436</code></li>
<li><code>812*375 @3x    2436*1125</code></li>
<li><code>414*736 @3x    1242*2208</code></li>
<li><code>736*414  @3x    2208*1242</code></li>
<li><code>375*667 @2x    750*1334</code></li>
<li><code>320*568 @2x    640*1136</code></li>
<li><code>320*480 @2x    640*960</code></li>
<li><code>320*480 @1x    320*480</code></li>
</ul></li>
</ul></li>
</ul>

<p><em>Xcode 配置注意事项</em></p>

<ul>
<li>强制https：如果现版本APP还需要访问http请求那么需要配置info.plist文件</li>
<li>release模式：开发者都懂得。</li>
<li>证书配置：确保上架期间证书不要失效即可。</li>
<li>功能配置：比如推送、支付、蓝牙等</li>
<li>APPgroup配置 功能新的数据存储共享等需要注意，详情请自行百度。</li>
<li>Info.plist权限配置：后台声音、网络数据、推送、地理位置、摄像头权限、相册权限等</li>
</ul>

<h2 id="toc_2">AppStore 上架</h2>

<h3 id="toc_3">APP信息</h3>

<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fkvh47o1voj31330hx0uf.jpg" alt="APP信息截图"/></p>

<h4 id="toc_4">可本地化的信息</h4>

<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fkvksptazij30ky04q75q.jpg" alt="AppStore 中APP列表显示"/></p>

<h5 id="toc_5">名称</h5>

<p>App Title（名称）允许255个字节，大概90个字符，原则上充分利用所有字符；例如《趣味牛牛－史上最休闲的游戏，天天QQ微信博易空间飞车坑爹泡泡龙12306狗我多米虾音乐节奏大师，找你妹酷跑保卫萝卜陌陌游览器爱消除yyppstv，炸金花全民英雄NBA快播联盟魔漫相机斗地主风行唱吧》。随着苹果审核愈趋严格的大环境下，单纯的热词堆砌是行不通的，在热词填充APP Title时需要保证语句的通畅以及无矛盾存在（苹果审核人员的汉语理解能力这两年可用突飞猛进形容）</p>

<h5 id="toc_6">副标题</h5>

<p>App 摘要，显示在APP详情中。如果客户的设备运行 iOS 11 或更高版本，在 App Store 中，副标题会显示在您的 App 名称下方。<br/>
利用副标题的高权重，采用轮换战术，优化各个关核心键词，当已有核心关键词排名优化靠前，选用其他的核心关键词</p>

<h5 id="toc_7">隐私政策网站</h5>

<p>APP涉及隐私权限问题的保护策略声明等。对APP用户信息保密性要求高的比如支付等功能可能需要提供一个隐私声明网页。</p>

<h4 id="toc_8">综合信息</h4>

<h5 id="toc_9">套装ID</h5>

<p>就是APP开发过程中的跟证书保持一致的 boundleID,功能上用来唯一标识APP的字符串.</p>

<h5 id="toc_10">SKU</h5>

<p>一个系列APP的成为套装，如Word、Excel，这个名字有辨识度即可。</p>

<h5 id="toc_11">Apple ID</h5>

<p>APP上架后再APPStore的身份ID，APP创建的时候自动生成，并且不可改变。</p>

<h5 id="toc_12">主要语言</h5>

<p>APP所支持的国际化语言，比如简体中文，繁体中文，英文等。</p>

<h5 id="toc_13">许可协议</h5>

<p>详情请参考: <a href="https://www.apple.com/legal/internet-services/itunes/dev/stdeula/">Apple标准许可协议</a></p>

<h5 id="toc_14">分级</h5>

<p>根据APP内容 （色情、暴力、赌博、广告等）进行评判的标准来定等级，看适合哪个年龄段的使用者下载。包含AppStore所限制的内容越少，越容易上架。<br/>
<img src="https://ws2.sinaimg.cn/large/006tNc79ly1fkvl0vs70kj318k1cbaj8.jpg" alt="等级分级"/></p>

<h5 id="toc_15">类别</h5>

<p>主要类别：<br/>
<img src="https://ws3.sinaimg.cn/large/006tNc79ly1fkvl7yz1tfj30qc0pmgnu.jpg" alt="主要类别分类"/><br/>
次要类别：<br/>
<img src="https://ws4.sinaimg.cn/large/006tNc79ly1fkvl9mmsyrj30pk0pgwgo.jpg" alt="次要类别分类"/></p>

<h3 id="toc_16">价格与销售范围</h3>

<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fkvlbvk29mj312v0gsmyl.jpg" alt="价格与销售范围"/></p>

<h4 id="toc_17">价格时间表</h4>

<p>这里可以选择定价的时间范围。比如 某一个时间段内APP限时免费。就可以规定一个价格，一个起止时间段。</p>

<h4 id="toc_18">销售范围</h4>

<p>比如有些APP只能在国内使用，那就选择中国🇨🇳。</p>

<h4 id="toc_19">批量购买计划</h4>

<p>大型APP的购买的优惠策略，现在通过AppStore的策略比较少了。现在的大型APP大都是免费下载，然后限时体验，体验时间过后在向你收费，如果觉得确实不错，用户就可以选择购买。这样对用户来说更合理。</p>

<h4 id="toc_20">Bitcode 自动重新编译</h4>

<p>这个是针对开发者的，大多数的老项目都不支持bitcode,新项目大都是支持的。<br/>
<img src="https://ws4.sinaimg.cn/large/006tNc79ly1fkvlm6sjuaj30qy0b576f.jpg" alt="bitcode自动变异详情"/></p>

<h3 id="toc_21">APP版本信息</h3>

<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fkvlqr205zj31kw0ttgwn.jpg" alt="APP版本信息"/></p>

<h4 id="toc_22">版本信息</h4>

<h4 id="toc_23">APP预览和屏幕快照</h4>

<p>iOS10之前，不同尺寸的手机都需要上传一套APP截图，每一套3-5张。</p>

<p><code>320*480</code><br/>
<code>320*568</code><br/>
<code>375*667</code><br/>
<code>414*736</code></p>

<p>iOS10之后apple放弃了对320*480尺寸的支持，所剩下的机型长宽比都是一致的，所以可以共用一套APP截图的，当然如果不嫌麻烦想不同机型有不同的展示截图可以选择iOS10之前的模式，上传多套看截图。</p>

<p>iOS10之后需要 <code>414*736</code>  @3x 三倍图 即：<code>1242 * 2208</code> 的截图。</p>

<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fkvm57vwduj31ag0f50ul.jpg" alt="APP截图可以选择公用5.5寸高清版本"/></p>

<h4 id="toc_24">宣传文本</h4>

<p>宣传文本可通知 App Store 访客当前最新的 App 功能，您无需提交更新请求。如果客户的设备运行 iOS 11 或更高版本，在 App Store 中，宣传文本会显示在您的 App 名称下方。</p>

<h4 id="toc_25">描述</h4>

<p>对APP的详细描述，主要模式：<br/>
哪家公司的什么APP干什么用有什么优点。</p>

<ul>
<li>描述性的字数控制在300-500，并保证核心关键词8-12的频次出现。</li>
<li>最好出现公司的联系方式，如公众号/微博账号/服务QQ/QQ群等。</li>
<li>描述中出现的关键词主要是对Keywords的补充，Keywords的权重和描述的权重是可以叠加的。</li>
</ul>

<h4 id="toc_26">关键词</h4>

<p>一个或多个关键词，用以描述您的 App。关键词将使 App Store 搜索结果更加准确。关键词之间用英文逗点分隔。</p>

<h4 id="toc_27">技术支持网址</h4>

<h4 id="toc_28">营销网址</h4>

<h4 id="toc_29">构建版本</h4>

<h4 id="toc_30">APP综合信息</h4>

<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fkvh124ghrj31370h5acw.jpg" alt=""/></p>

<h5 id="toc_31">AppStore图表</h5>

<p>1024*1024 没有开启alpha通道的PNG格式图片。</p>

<h5 id="toc_32">版本</h5>

<p>当前上架APP的版本号</p>

<h5 id="toc_33">分级</h5>

<p>同上</p>

<h5 id="toc_34">版权</h5>

<p>公司申请开发账号的时候就应该知道的，不清楚的吻公司账号申请人。</p>

<h5 id="toc_35">商务代表联系信息</h5>

<p>这个填写公司的上午代表联系人。个人开发账号那就是填写自己信息了。</p>

<h5 id="toc_36">APP审核信息</h5>

<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fkvgu6xxxlj31jx0phq80.jpg" alt="APP审核信息截图"/></p>

<ul>
<li>登录信息：如果APP需要登录APP则需要提供相应的测试账号，以便测试人员登录测试。</li>
<li>备注：请提供用户名和密码，以便Apple测试人员登录 App。apple测试人员需要使用此登录信息才能完成对您App 的审核。  或者APP的操作需要什么特殊的操作指引，也需要在这里进行备注。注：即使登录信息位置填写了账号密码，备注内仍建议再填写一遍，不排除有比较懒的测试人员，看不到你的账号信息。毕竟APP一旦打回，会耽误3-4天的上线时间。</li>
<li>联系信息：填写公司产品负责人的联系方式</li>
</ul>

<h2 id="toc_37">ASO优化</h2>

<p><a href="https://www.zhihu.com/question/23027114?rf=27740130">知乎详解ASO优化</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[当虹云直播SDK植入引导]]></title>
    <link href="http://blog.csdn.net/15130871866705.html"/>
    <updated>2017-12-12T21:59:46+08:00</updated>
    <id>http://blog.csdn.net/15130871866705.html</id>
    <content type="html"><![CDATA[
<hr/>

<h2 id="toc_0">一、导入静态库 libARCPlayerRecoder.a</h2>

<h2 id="toc_1">二、导入framework</h2>

<p>(img)</p>

<h2 id="toc_2">三、添加info.plist文件的授权选项 麦克风 摄像头权限授权申请</h2>

<p>(img)</p>

<h2 id="toc_3">四、.m文件 中引用 C++方法的时候 需要变为.mm文件</h2>

<h2 id="toc_4">五、变量类型转换</h2>

<p>self 改为 (__bridge void *) self<br/>
用  (__bridge void *)  进行类型的强制转换</p>

<span id="more"></span><!-- more -->

<h1 id="toc_5">六、真机测试</h1>

<p>真机运行才可以，不支持模拟器哦</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-c 2.0 学习笔记]]></title>
    <link href="http://blog.csdn.net/15130871696781.html"/>
    <updated>2017-12-12T21:59:29+08:00</updated>
    <id>http://blog.csdn.net/15130871696781.html</id>
    <content type="html"><![CDATA[
<p>编写高质量iOS与OS X代码的52个有效方法</p>

<h1 id="toc_0">第一章 熟悉Objective-C</h1>

<h2 id="toc_1">第1条 了解Objective-C语言的起源</h2>

<ol>
<li>笔记：</li>
<li>OC是动态语言，使用<code>消息结构</code>(messaging structure),而非<code>函数调用</code>(function calling)。OC由消息语言的鼻祖smalltalk演化而来。</li>
<li>区别：消息结构的语言，其运行时执行的代码由运行环境决定；函数调用的语言，则由编译器决定。</li>
<li>OC中对象所占内存总是分配在<code>堆空间</code>(heap space)而不会在<code>栈空间</code>(stack)上</li>
<li><p>OC中不带*的变量，有可能会使用<code>栈空间</code>，比如CGRect 结构体<br/>
~~ <code><br/>
~~ struct CGRect{<br/>
~~     CGPoint point;<br/>
~~     CGSize size;<br/>
~~ };<br/>
~~</code><br/>
因为创建对象需要额外开销（分配&amp;释放堆内存），从效率上，结构体性能更好。</p></li>
<li><p>要点</p></li>
<li><p>Objective-c为C语言天减了面向对象特性，是其超集。Objective-C是使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收这一消息后，究竟该执行何种代码实现，有运行期环境决定而非编译器。</p></li>
<li><p>理解C语言的核心概念有助于写好Objective-C程序，尤其是掌握内存模型与指针。</p></li>
</ol>

<span id="more"></span><!-- more -->

<h2 id="toc_2">第2条 在类的头文件中尽量少引用其他头文件。</h2>

<ol>
<li>笔记：</li>
<li>头文件导入时，如非使用者必须知道，尽量将头文件的导入时机延后（头文件的导入反倒.m文件中），这样会大大减少编译时间，减少头文件之间相互依赖的复杂度。</li>
<li><p>前向声明---<code>@class ClassName</code>这种头文件的声明方式(或者引入方式)叫做<code>前向声明</code>（或者向前声明）--- (forward declaring);前向声明方式引入的头文件，不会在编译期间进行编译，只是向声明我这里有这么各类，你知道有就行了，不需要你编译。这种方式还能解决头文件相互包含的问题。</p></li>
<li><p>要点：</p></li>
<li><p>除非有必要条件，否则不要引入头文件。一般来说，应在某各类的头文件中使用前向声明来提及别的类，并在实现文件中引入哪些类的头文件。这样做可以尽量降低类之间的<code>耦合</code>（coupling）</p></li>
<li><p>有时无法使用前向声明，比如要声明某个类遵循一项协议。这情况下，尽量把“该类遵循某协议”的这条生命移至&quot;class-continuation分类&quot;中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。</p></li>
</ol>

<h2 id="toc_3">第3条 多用字面量语法，少用与之等价的方法</h2>

<p>~~ <code><br/>
~~ //字面量语法<br/>
~~ NSString *str1 = @&quot;Kael&quot;;<br/>
~~ <br/>
~~ //传统方式<br/>
~~ NSString *str2 = [[NSString alloc] initWithFormat: @&quot;Kael&quot;];<br/>
~~</code></p>

<ol>
<li>笔记：</li>
<li>字面量语法（literal syntax）能极大的缩短代码长度，使其更易读。</li>
<li><p>字面数值 传统方式：<code>NSNumber *someNumber = [NSNumber numberWithInt:1]</code></p>

<ol>
<li><code>NSNumber *intNumber = @1</code></li>
<li><code>NSNumber *floatNumbser = @0.125f</code></li>
<li><code>NSNumber *doubleNum = @3.14159</code></li>
<li><code>NSNumber *boolNum = @YES</code></li>
<li><code>NSNumber *charNum = @&#39;abc&#39;</code></li>
</ol></li>
</ol>

<ul>
<li>字面量数组 传统方式：<code>NSArray *animals = [NSArray arrayWithObjects:@&quot;cat&quot;,@&quot;dog&quot;,@&quot;mouse&quot;,nil];</code>

<ul>
<li><code>NSArray *animals = @[@&quot;cat&quot;,@&quot;dog&quot;,@&quot;mouse&quot;];</code></li>
<li><code>NSString *dog = animals[1];</code></li>
<li><code>replaceObjectAtIndex:index</code> -&gt; <code>mutableArray[1] = @&quot;dog&quot;;</code></li>
</ul></li>
<li><p>字面量字典 传统方式：<code>NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndkeys:@&quot;kael&quot;,@&quot;name&quot;,@&quot;age&quot;,@&quot;18&quot;,nil];</code></p>

<ul>
<li><code>NSDictionary *personData = @{@&quot;name&quot;:@&quot;kael&quot;,@&quot;age&quot;:@&quot;18&quot;}</code></li>
<li><code>NSString *name = personData[@&quot;name&quot;];</code></li>
<li><code>setObject:obj forKey:key</code> -&gt; <code>mutableDic[name] = @&quot;kaelinda&quot;;</code></li>
</ul></li>
</ul>

<ol>
<li>要点：

<ol>
<li>字面量语法创建 字符串、数值、数组、字典 比常规方法更加简明扼要。</li>
<li>应该通过取下标方式来取 字典、数组 中的值。</li>
<li>用字面量语法创建数组或者字典时，若值中有nil,则会抛出异常。因此，务必确保值中不含nil。</li>
</ol></li>
</ol>

<h2 id="toc_4">第4条 多用类型常量，少用#define 预处理命令</h2>

<ol>
<li><p>笔记：</p>

<ol>
<li>宏定义等用于处理命令 是在编译器 编译期间 将定义的 字符替换，所以这样的缺点是 不能很好的从宏定义上读出常量的类型信息。</li>
<li><code>static const NSTimeInterval kAnimationinDuration = 0.3;</code></li>
<li><code>extern NSString *const EOCString;</code>比如 通知等需要有一个外部可见的变量作为 <strong>通知名</strong></li>
</ol></li>
<li><p>要点：</p>

<ol>
<li>不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器编译期间，已经把这些值写死了，如果有人对常量改动，编译器也不会产生警告信息；</li>
<li>在实现文件中(.m文件)使用<code>static const</code>来定义只在编译单元可见(只在.m文件中可见，不暴露给外部使用)的常量。因此常量不在全局符号表中，命名上不需要在名称上加前缀。</li>
<li>在头文件中用<code>extern</code>来声明全局常量，并在相关实现文件中定义其值。</li>
</ol></li>
</ol>

<h2 id="toc_5">建议：处理隐藏的返回类型，优先选择实例类型而非id类型</h2>

<ol>
<li>笔记：

<ol>
<li><code>instancetype</code>仅仅用作Objective-C方法的返回类型</li>
<li><code>instancetype</code>有类型检测，更安全
*</li>
</ol></li>
</ol>

<h2 id="toc_6">建议：尽量使用模块方式与多类建立复合关系</h2>

<ul>
<li><code>#import</code> 和 <code>#include</code> 其根本就是简单的复制、粘贴，将.h文件中的内容一字不落的复制到当前文件中，<code>#import</code>可避免头文件的重复引用。</li>
<li>以预编译头文件的方式，虽然可以缩短编译时间，但维护棘手，不利于广泛应用。</li>
<li>模块功能，其应用不仅仅变现与编译的速度加快，同事在链接框架等方面也非常好用。</li>
<li>启动模块功能后，编译器会隐式的把所有的<code>#import</code>转换成<code>@import</code></li>
</ul>

<h2 id="toc_7">高度警惕空指针和野指针的袭击</h2>

<ol>
<li><p>笔记：</p>

<ol>
<li>nil、Nil、NULL的区别：
nil：指向oc中对象的空指针，针对对象。
Nil：指向oc中类的空指针，针对类。
NULL：指向其他类型的空指针，如一个c类型的内存指针，基本数据类型为空，基本类型。
NSNull：在集合对象中，表示空值的对象。</li>
</ol></li>
<li><p>要点：</p>

<ol>
<li>空指针（NULL）指的是没有存储任何内存地址的指针；野指针，是指向“垃圾内存”（不可用内存）的指针。</li>
<li>利用野指针发消息是很危险的，会报错。也就是说，一个对象被回收了，就不要再去操作它，不要尝试给它发消息。</li>
<li>利用空指针发消息是没有任何问题的，也就是说代码是没有错误的。</li>
</ol></li>
</ol>

<h2 id="toc_8">清楚长两字符串和一般字符串的区别</h2>

<p>~~ <code><br/>
~~ NSString *string1 = @&quot;hello&quot;;<br/>
~~ NSString *string2 = @&quot;hello&quot;<br/>
~~ if (strng1 == string2){<br/>
~~     NSLog(@&quot;They are same address&quot;);<br/>
~~ };<br/>
~~ <br/>
~~ NSString *string3 = [NSString alloc];<br/>
~~ nsstring *string4 = [string3 initWithString:string1];<br/>
~~ if (string3!=string4){<br/>
~~     NSLog(@&quot;string3 is not same to string4&quot;);<br/>
~~ }<br/>
~~ <br/>
~~ if (string1 == string4){<br/>
~~     NSLog(@&quot;string1 is same to string4&quot;);<br/>
~~ }<br/>
~~ <br/>
~~</code></p>

<ul>
<li>由于编译器的优化，相同内容的常量字符串的地址是完全相同的。</li>
<li>如果用常量字符串来初始化一个字符串，那么这两个字符串也将是相同的常量。</li>
<li>对常量字符串永远不要release,因为多次release都还能访问。</li>
</ul>

<h2 id="toc_9">第5条 用枚举表示状态、选项、状态码</h2>

<ol>
<li>笔记：</li>
<li>想要将多个枚举能同时生效（例如，屏幕的方向），那需要枚举值设置为 2 的n次幂；</li>
<li><p>还可以通过按位操作</p></li>
</ol>

<ul>
<li><p>NS_ENUM与NS_OPTIONS区别：</p>

<ul>
<li>NS_ENUM枚举项的值为NSInteger，NS_OPTIONS枚举项的值为NSUInteger；</li>
<li>NS_ENUM定义通用枚举，NS_OPTIONS定义位移枚举</li>
<li>NS_OPTIONS的枚举项的值需要像这样表示1 &lt;&lt; 0，1 &lt;&lt; 1，2的几次方这样，而NS_ENUM可以直接给像1，2，3这样</li>
</ul></li>
</ul>

<ol>
<li>要点：</li>
<li>在处理枚举类型的switch语句时，不要使用default分支，这样加入新枚举时编译器会提醒开发者：switch语句并未处理所有枚举。</li>
</ol>

<hr/>

<h1 id="toc_10">第二章</h1>

<hr/>

<h2 id="toc_11">第6条 理解属性这一概念</h2>

<ol>
<li><p>笔记：</p>

<ul>
<li>属性(property) = 成员变量 + getter + setter</li>
<li>创建属性后，编译器会自动生成setter、getter属性</li>
</ul>

<p>属性特质：<br/>
&#39;&#39; 1. 原子性：nonatomic 线程不安全；atomic 原子性，通过线程锁定等保证其原子性；<br/>
&#39;&#39; 2. 读/写权限：readwrite———可读可写（setter、getter）;readonly———只读。<br/>
&#39;&#39; 3. 内存管理语义：assign（弱引用）、weak（弱引用）、strong(强引用)、copy(强引用)、unsafe_unretained(针对于对象的 类似于assign)<br/>
&#39;&#39; 4. 方法名：<br/>
&#39;&#39;   - <code>getter=&lt;name&gt;</code> --&gt; 指定“获取方法”的方法名  @property （nonatomic,getter=isOn）BOOL on;<br/>
&#39;&#39;   - <code>seeter=&lt;name&gt;</code> --&gt; 指定设置方法的方法名 @property （nonatomic,getter=isOn,seeter=setBaseModelName）BOOL on;</p></li>
</ol>

<h2 id="toc_12">第7条 在对象内部尽量直接访问实例变量</h2>

<ul>
<li>直接访问实例变量，不会走<code>方法派送</code>(method dispatch);直接访问实例变量速度上要快得多。</li>
<li>直接访问实例变量，不会调用“设置方法”（setter）,ARC下copy修饰的属性，就不会copy该属性，只会保留新值并释放旧值。</li>
<li>直接访问实例变量，不会触发“键值观察（Key-ValueObserving，KVO）”</li>
<li>通过属性访问，可以通过setter、getter增加断点监控键值变化。</li>
</ul>

<p>折中：设置变量时走setter方法；获取变量值时直接访问实例变量；</p>

<p>注意：<br/>
* 初始化方法(或者 dealloc)中设置属性值的时候，应该直接访问实例变量，因为子类可能会<code>覆写</code>该方法;<br/>
* 惰性初始化来配置数据，这时候需要通过属性来读取数据。</p>

<h2 id="toc_13">第8条 理解“对象等同性”这一概念</h2>

<ol>
<li>笔记：
对象等同性比较：</li>
<li><code>==</code>比较的是指针本身</li>
<li><code>isEqual:</code>方法比较的是指针指向的内存地址</li>
</ol>

<p>NSobject协议中有两个判断等同性的关键方法：<br/>
~~ <code><br/>
~~ -(BOOL)isEqual:(id)object;<br/>
~~ -(NSUInteger)hash;<br/>
~~</code><br/>
2. 要点：<br/>
2. 相同的对象必须具有相同的哈希码；<br/>
3. 拥有相同哈希码的对象不一定相同；</p>

<h2 id="toc_14">第9条 以“类族模式”隐藏实现细节</h2>

<p>1.笔记：</p>

<ul>
<li>基类  + 分工的子类</li>
<li>子类都应当继承自类族中的抽象基类。</li>
<li>子类应该定义自己的数据存储方式。</li>
<li><p>子类应当覆写超类文档中指明需要覆写的方法。</p>

<p>2.要点:</p></li>
<li><p>类族模式可以把实现细节隐藏在一套简单的公共接口后面。</p></li>
<li><p>系统框架中经常使用类族。</p></li>
<li><p>从类族的公共抽象基类中集成子类是要当心，若文档有变化，则应当先阅读。</p></li>
</ul>

<h2 id="toc_15">第10条：在既有类中使用关联对象存放自定义数据</h2>

<h2 id="toc_16">第12条：理解 objc_msgSend 的作用</h2>

<h2 id="toc_17">第13条：</h2>

<h2 id="toc_18">第14条：</h2>

<h2 id="toc_19">第15条：</h2>

<h2 id="toc_20">第16条：</h2>

<h2 id="toc_21">第17条：</h2>

<h2 id="toc_22">第18条：</h2>

<h2 id="toc_23">第19条：</h2>

<h2 id="toc_24">第20条：</h2>

<h2 id="toc_25">第21条：</h2>

<h2 id="toc_26">第22条：</h2>

<h2 id="toc_27">第23条：</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于iOS沙盒文件的那些事儿]]></title>
    <link href="http://blog.csdn.net/15129168744096.html"/>
    <updated>2017-12-10T22:41:14+08:00</updated>
    <id>http://blog.csdn.net/15129168744096.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">分类</h2>

<ul>
<li>Document： 除了基于NSUserdefaults的首选项设置之外,应用程序的数据，文件都存在该目录下</li>
<li>Libary：基于NSUserDefaults的首选项参数保存在Liabry/prefrences目录下</li>
<li>tmp:</li>
</ul>

<span id="more"></span><!-- more -->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS代码检测入坑记事]]></title>
    <link href="http://blog.csdn.net/15126628432953.html"/>
    <updated>2017-12-08T00:07:23+08:00</updated>
    <id>http://blog.csdn.net/15126628432953.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">我接触的代码检测</h2>

<ul>
<li>OCLint + xcpretty</li>
<li>sonar</li>
<li>infer</li>
</ul>

<h3 id="toc_1">infer</h3>

<ul>
<li><p><a href="https://infer.liaohuqiu.net">infer官网 传送门</a></p>

<p><em>具体使用</em></p>

<pre><code>infer -- xcodebuild -target &lt;target name&gt; -configuration &lt;build configuration&gt; -sdk iphonesimulator
</code></pre></li>
</ul>

<span id="more"></span><!-- more -->

<p><em>例如：</em><br/>
  ```<br/>
  #分析之前先把之前的build缓存清理下<br/>
  xcodebuild -workspace HIGHTONG_Public.xcworkspace -scheme HIGHTONG_Jktv -configuration Debug -sdk iphoneos11.0</p>

<p>#根据自己醒目名字使用infer 命令进行分析<br/>
  infer -- xcodebuild -workspace HIGHTONG_Public.xcworkspace -scheme HIGHTONG_Jktv -configuration Debug -sdk iphoneos11.0<br/>
  ```</p>

<p><em>infer的优势</em></p>

<ul>
<li>安装过程简洁，不需要过多的配置（前提是电脑之前安装过Homebrow）</li>
<li>使用方便，只需要一行命令</li>
</ul>

<h3 id="toc_2">sonar</h3>

<p>Sonar 是一个用于代码质量管理的开放平台。通过插件机制，Sonar 可以集成不同的测试工具，代码分析工具，以及持续集成工具。相比于Jenkins ，sonar更关注代码的变化，通过量化的方式度量代码变化。</p>

<p>如果不需要持续集成，sonar只需要两个配置文件就可以进行代码的静态检测。</p>

<ul>
<li>安装： <code>brew install sonar</code></li>
<li>配置文件修改 <code>run-sonar.sh</code> <code>sonar-project.properties</code></li>
<li><p>执行run-sonar.sh脚本，检测代码</p>

<p><em>资源下载</em></p>

<ul>
<li><p><a href="https://raw.githubusercontent.com/octo-technology/sonar-objective-c/master/src/main/shell/run-sonar.sh">run-sonar.sh</a></p></li>
<li><p><a href="https://raw.githubusercontent.com/octo-technology/sonar-objective-c/master/sample/sonar-project.properties">sonar-project.properties</a></p></li>
</ul>

<p><em>参考资源</em></p>

<ul>
<li><p><a href="http://www.jianshu.com/p/f58e89573d33">IOS-Sonar代码质量监控</a></p></li>
<li><p><a href="https://my.oschina.net/ChenTF/blog/806565">[实践]Sonar Xcode8兼容</a></p></li>
<li><p><a href="http://www.jianshu.com/p/74bee59fef1c">iOS Sonar集成流程详解</a></p></li>
<li><p><a href="http://www.jianshu.com/p/6b61783b9a38">基于Sonar的iOS代码质量检测系统</a></p></li>
<li><p><a href="http://blog.csdn.net/itfootball/article/details/45058591">IOS测试之sonar检查ios代码质量</a></p></li>
</ul></li>
</ul>

<h3 id="toc_3">OCLint + xcpretty</h3>

<ul>
<li><p>安装xcpretty</p>

<pre><code>sudo gem install xcpretty
</code></pre></li>
<li><p>安装OCLint<br/>
```<br/>
brew tap oclint/formulae</p>

<p>brew install oclint<br/>
```</p></li>
<li><p>根目录下 运行脚本：<br/>
```</p>

<h1 id="toc_4">清理</h1>

<p>xcodebuild clean</p>

<h1 id="toc_5">生成JSON文件 用于分析</h1>

<p>xcodebuild  -workspace demo.xcworkspace -scheme demo -configuration Debug \<br/>
| tee xcodebuild.log \<br/>
| xcpretty -r json-compilation-database -o compile_commands.json</p>

<h1 id="toc_6">OCLint 分析（根据一定规则进行分析）</h1>

<p>oclint-json-compilation-database -v \<br/>
-e Pods \<br/>
-e MGLivenessDetection \<br/>
-e MGBaseKit \<br/>
-e MGIDCard \<br/>
oclint_args -- -report-type html -o oclintReport.html \<br/>
-disable-rule ObjCAssignIvarOutsideAccessors \<br/>
-disable-rule ShortVariableName \<br/>
-rc=MINIMUM_CASES_IN_SWITCH=3 \<br/>
-rc=CYCLOMATIC_COMPLEXITY=10 \<br/>
-rc=LONG_CLASS=700 \<br/>
-rc=LONG_LINE=200 \<br/>
-rc=NCSS_METHOD=40 \<br/>
-rc=NESTED_BLOCK_DEPTH=5 \<br/>
-rc=TOO_MANY_FIELDS=20 \<br/>
-rc=TOO_MANY_METHODS=30 \<br/>
-rc=TOO_MANY_PARAMETERS=6</p>

<h1 id="toc_7">oclint_args -- -report-type xcode \</h1>

<pre><code>
高级用法，代码检测规则：
</code></pre></li>
<li><p><a href="http://www.jianshu.com/p/4f505e92d557">iOS使用OCLint做静态代码分析</a></p></li>
<li><p><a href="http://www.cocoachina.com/ios/20170928/20669.html">让XCode自动CodeReview你的代码-OCLint使用</a></p></li>
<li><p><a href="https://blog.yourtion.com/static-code-analysis-ios-using-oclint.html">iOS静态代码扫描</a>  <a href="https://blog.yourtion.com/static-code-analysis-ios-using-oclint.html">原文链接</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS WKWebView 本地HTML、JS、CSS文件加载详解]]></title>
    <link href="http://blog.csdn.net/15126415331235.html"/>
    <updated>2017-12-07T18:12:13+08:00</updated>
    <id>http://blog.csdn.net/15126415331235.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><strong>Tips:</strong><br/>
NSString类型的文件路径转换为URL的时候，一定要用 <br/>
<code>NSURL *pathURL = [NSURL fileURLWithPath:filePath];</code>方法去转换，否则资源URL不合法，APP会崩溃</p>
</blockquote>

<h2 id="toc_0">上源码接口：</h2>

<h3 id="toc_1">loadRequest方式加载</h3>

<ul>
<li><p>API : iOS8即可使用</p>

<p><code>- (nullable WKNavigation *)loadRequest:(NSURLRequest *)request;</code>      </p></li>
<li><p>用途：</p>

<ul>
<li>1：主要用来加载网络URL<br/></li>
<li>2：也可以加载本地HTML文件（本文重点）</li>
</ul>

<span id="more"></span><!-- more --></li>
</ul>

<h3 id="toc_2">loadFileURL</h3>

<ul>
<li><p>API: URL:文件相对路径 readAccessURL：访问文件需要引用的文件的路径 一般都是比<code>URL</code>大一级或者更高几级</p>

<p><code>- (nullable WKNavigation *)loadFileURL:(NSURL *)URL allowingReadAccessToURL:(NSURL *)readAccessURL API_AVAILABLE(macosx(10.11), ios(9.0));</code></p></li>
<li><p>用途：主要用于加载本地文件（一般指相对路径）</p></li>
</ul>

<h3 id="toc_3">loadHTMLString</h3>

<ul>
<li><p>API:<br/>
<code>- (nullable WKNavigation *)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;</code></p></li>
<li><p>用途：主要用于 HTML转换成的字符串（比如：编程APP）</p></li>
</ul>

<h3 id="toc_4">loadData</h3>

<ul>
<li><p>API: 值得一提的是MIMETType,text/html、image/jpg、text/plain</p>

<p><code>- (nullable WKNavigation *)loadData:(NSData *)data MIMEType:(NSString *)MIMEType characterEncodingName:(NSString *)characterEncodingName baseURL:(NSURL *)baseURL API_AVAILABLE(macosx(10.11), ios(9.0));</code></p></li>
<li><p>用途：主要用于加载 二进制状态下的文件，主要包括HTML、Image、Text文本</p></li>
</ul>

<h2 id="toc_5">开发中的HTML文件位置</h2>

<h3 id="toc_6">HTML位于工程内的黄色文件夹下</h3>

<blockquote>
<p>这是咱们一般的文件添加方式，这属于绝对路径的添加</p>
</blockquote>

<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fmcxnu043cj313w05maan.jpg" alt="绝对路径"/></p>

<h4 id="toc_7"><strong><code>loadRequest</code> 加载方式</strong></h4>

<blockquote>
<p><strong>Tips:</strong><br/>
 iOS8 的时候只能通过这个<code>loadRequest</code>方法去加载<br/>
iOS8 WKWebView的加载本地文件的方式本文后面会有 <strong>详细方案</strong></p>
</blockquote>

<pre><code class="language-Objectiv-C">NSString *bundleStr = [[NSBundle mainBundle] pathForResource:@&quot;feedback&quot; ofType:@&quot;html&quot;];
    
_feedbackUrl = [NSURL fileURLWithPath:bundleStr];
    
[_webview loadRequest:[NSURLRequest requestWithURL:_feedbackUrl]];
</code></pre>

<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fmcxsxa56jj30af0j5dgd.jpg" alt="效果"/></p>

<p><strong>warning！！！</strong><br/>
页面能加载出来，但是效果是很差的，因为CSS、JS、图片资源文件没有得到正确的引用！<br/>
那我们该通过什么方式来让这些附属的文件得到正确引用呢？<br/>
iOS9之后新增了 <code>loadFileURL</code> 等一系列加载本地文件的方法</p>

<h4 id="toc_8"><strong><code>loadFileURL</code>加载方式</strong></h4>

<blockquote>
<p>iOS9之后才出现这个加载方式</p>
</blockquote>

<pre><code class="language-Objectiv-C">NSString *bundleStr = [[NSBundle mainBundle] pathForResource:@&quot;feedback&quot; ofType:@&quot;html&quot;];
_feedbackUrl = [NSURL fileURLWithPath:bundleStr];
if (@available(iOS 9.0, *)) {
    [_webview loadFileURL:[NSURL fileURLWithPath:bundleStr] allowingReadAccessToURL:[NSURL fileURLWithPath:[NSBundle mainBundle].bundlePath]];
} else {
    // Fallback on earlier versions
}
</code></pre>

<p>哇塞！加载出来了耶！但是 依旧是没能加载其他资源文件啊 😰<br/>
客观，稍安勿躁 ~</p>

<h3 id="toc_9">HTML位于工程内的蓝色文件夹下</h3>

<blockquote>
<p>特殊文件添加方式，尤其是文件之间有相互引用的时候用这种方式</p>
</blockquote>

<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fmcxr0jl88j313w05maan.jpg" alt="相对路径添加方式"/></p>

<h4 id="toc_10">loadRequest 方式</h4>

<pre><code class="language-Objectiv-C">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;feedback&quot; ofType:@&quot;html&quot; inDirectory:@&quot;FeedbackH5/pages&quot;];
NSURL *pathURL = [NSURL fileURLWithPath:filePath];
if (@available(iOS 9.0, *)) {
    [_webview loadRequest:[NSURLRequest requestWithURL:pathURL]];
}
</code></pre>

<h4 id="toc_11">loadFileURL 方式加载</h4>

<pre><code class="language-Objectiv-C">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;feedback&quot; ofType:@&quot;html&quot; inDirectory:@&quot;FeedbackH5/pages&quot;];
    NSURL *pathURL = [NSURL fileURLWithPath:filePath];
    if (@available(iOS 9.0, *)) {
//        [_webview loadRequest:[NSURLRequest requestWithURL:pathURL]];
        [_webview loadFileURL:[NSURL fileURLWithPath:filePath] allowingReadAccessToURL:[NSURL fileURLWithPath:[NSBundle mainBundle].bundlePath]];
    }
</code></pre>

<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fmcyc9pjp0j30af0j5wfp.jpg" alt=""/></p>

<blockquote>
<p>由此可见：相对路径方式加载 是可以正常引用JS、css等资源文件的<br/>
但是 iOS 8系统下，依旧加载不出来！！！</p>
</blockquote>

<h3 id="toc_12">HTML位于APP沙盒下Document文件夹</h3>

<blockquote>
<p>iOS8既然添加到工程中引用，一直引用不到，我们可以让他从document路径下引用试试！<br/>
这个方法可以适配 iOS8系统下WKWebView加载本地文件了？<br/>
你还太天真！！！</p>
</blockquote>

<pre><code class="language-Objectiv-C">//项目中的文件夹路径
NSString *directoryPath = [KFileManger appSourceName:@&quot;FeedbackH5&quot; andType:@&quot;&quot;];

//沙盒中的document路径
NSString *documentpath = [KFileManger documentPath];
    
//copy文件夹到 document 路径下
[KFileManger copyMissingFile:directoryPath toPath:documentpath];

//document 路径下的HTML文件路径
NSString *homePath = [[KFileManger documentPath] stringByAppendingString:@&quot;/FeedbackH5/pages/feedback.html&quot;];

//document 路径下的HTML文件 URL
NSURL *docSourceURL = [NSURL fileURLWithPath:homePath];
    
[_webview loadRequest:[NSURLRequest requestWithURL:docSourceURL]];
</code></pre>

<blockquote>
<p>果然不出所料(zhe jiu shi wo xiang yao de)，模拟器上能正常加载出界面，图片、CSS但是JS交互是不行的<br/>
在真机 依旧加载不出任何界面！</p>
</blockquote>

<h3 id="toc_13">HTML位于APP沙盒下tmp临时缓存文件夹</h3>

<blockquote>
<p>亲爱的客观们，这才是iOS8系统下加载有相互引用关系的HTML、JS、CSS以及图片资源的正确方法(当前知道的唯一方法如有新的方式私信我哦~)！😊</p>
</blockquote>

<pre><code class="language-Objectiv-C">//项目中的文件夹路径
NSString *directoryPath = [KFileManger appSourceName:@&quot;FeedbackH5&quot; andType:@&quot;&quot;];

//tmp缓存文件夹路径
NSString *tmpPath = [KFileManger tmpPath];

//新文件夹名字
NSString *wwwDir =@&quot;www&quot;;

//tmp文件夹下创建www文件夹
[KFileManger createDirWithPath:tmpPath andDirectoryName: wwwDir];

//tmp中的www文件夹中的路径
NSString *tmpWWW = [tmpPath stringByAppendingString: wwwDir];

//copy文件夹到 tmp/www 路径下
[KFileManger copyMissingFile:directoryPath toPath:tmpWWW];

// 字符 tmp/www/FeedbackH5/pages/feedback.html 全路径
NSString *tmpWWWFeedback = [tmpWWW stringByAppendingString:@&quot;/FeedbackH5/pages/feedback.html&quot;];

//tmp 操作，字符转换成URL
NSURL *feedbackURL = [NSURL fileURLWithPath:tmpWWWFeedback];

//WKWebView加载
[_webview loadRequest:[NSURLRequest requestWithURL:feedbackURL]];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可选型 Optional]]></title>
    <link href="http://blog.csdn.net/15117133773045.html"/>
    <updated>2017-11-27T00:22:57+08:00</updated>
    <id>http://blog.csdn.net/15117133773045.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">定义</h3>

<ul>
<li>当数据可能接收nil的时候，使用optional是比较合适的</li>
<li>当非可选型被赋值为nil的时候 系统会崩溃</li>
<li>当可选型被赋值为nil的时候 系统会首先判断值是否为nil，如果为nil 则会赋值nil;如果不为nil，那就正常操作。</li>
</ul>

<h3 id="toc_1">Optional 可选型 写法</h3>

<p><code>var sexy : String? = &quot;boy&quot;</code></p>

<h3 id="toc_2">强制解包</h3>

<pre><code>if sexy != nil {
    print(&quot;i am a \(String(describing: sexy))&quot;)
}else{
    print(&quot;none&quot;)
}
</code></pre>

<span id="more"></span><!-- more -->

<h3 id="toc_3">官方推荐解包方式</h3>

<pre><code>if let ksex = sexy {
    print(&quot;i am a \(ksex)&quot;)
}else{
    print(&quot;none&quot;)
}
</code></pre>

<h3 id="toc_4">隐式解包 定义时候后面跟着！就可以隐式解包</h3>

<pre><code>var sexy2 : String!
var sexy3 : String = sexy2 ?? &quot;boy&quot;//使用的时候不需要进行解包 并且可以通过 ?? 给变量赋一个默认值
</code></pre>

<h3 id="toc_5">使用Optional的变量 首先要解包</h3>

<pre><code>if...else
guard ... else{}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 代码块]]></title>
    <link href="http://blog.csdn.net/15115332074317.html"/>
    <updated>2017-11-24T22:20:07+08:00</updated>
    <id>http://blog.csdn.net/15115332074317.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">一、创建自定义代码块的好处</h2>

<p>由于项目、所用语言或者编码习惯的差别，不同的程序员习惯用的代码片段也不尽相同，这就有了自定义代码片段的需求，好在Xcode是支持该功能的。他的好处是使程序员以最快的速度输入很常用的代码片段，提高编程效率。</p>

<p>该功能是从Xcode4开始引入的。在Xcode中的位置如下图所示：</p>

<p>如上图，右边系统就定义很对的代码块，包括一些我们很常用的@interface 和@implementation的声明和实现。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">二、自定义我们常用的代码块步骤</h2>

<p>Ｅｇ：@property属性的定义是Cocoa程序开发中很常用的一个功能，下面就以此为例说明如何自定义代码片段。</p>

<ol>
<li>书写代码片段</li>
</ol>

<p>在声明@property属性的地方写下如下语句：</p>

<p>@property (nonatomic, retain) &lt;#type#&gt; &lt;#name#&gt;;</p>

<p>这里&lt;#type#&gt;和&lt;#name#&gt;起什么作用可以在后面的使用效果中看出来。</p>

<ol>
<li>新建代码片段</li>
</ol>

<p>１）点击Code Snippet Library</p>

<p>2)选择User 用户自定义</p>

<p>3）出现如下空白界面</p>

<p>4）把刚编辑好的代码选中，拖到上面的空白处，出现如下的编辑窗口</p>

<p>图中从上到下的含义依次是：</p>

<p>①Title</p>

<p>代码片段的标题</p>

<p>②Summary</p>

<p>代码片段的描述文字</p>

<p>③Platform</p>

<p>可以使用代码片段的平台，有IOS/OS X/All三个选项</p>

<p>④Language</p>

<p>可以在哪些语言中使用该代码片段</p>

<p>⑤Completion Shortcut</p>

<p>代码片段的快捷方式，比如本文开头用到的dowhile，在这里，把属性设置的快捷方式设为property</p>

<p>⑥Completion Scopes</p>

<p>可以在哪些文件中使用当前代码片段，比如全部位置，头文件中等，当然可以添加多个支持的位置。</p>

<p>最后的一个大得空白区域是对代码片段的效果预览。</p>

<p>一切设置完成以后，点击该菜单右下角的Done按钮，新建工作就结束了。</p>

<p>5）验证效果：我在代码里面输入”pro“ 即出现如下提示：（直接点击Enter键，一整条语句就自动补齐了）</p>

<h2 id="toc_2">三、代码片段的备份</h2>

<p>Xcode中的代码片段默认放在下面的目录中：</p>

<p>~/Library/Developer/Xcode/UserData/CodeSnippets</p>

<p>我们可以将目录中的代码片段备份，也可以将其直接拷出来放在不同的电脑上使用，因此多台电脑之间的协作也毫无压力。</p>

<h2 id="toc_3">福利传送门</h2>

<p>常用的：<br/>
1.strong：<br/><br/>
<code><br/>
@property (nonatomic,strong) &lt;#Class#&gt; *&lt;#object#&gt;;<br/>
</code></p>

<p>2.weak：<br/><br/>
<code>@property (nonatomic,weak) &lt;#Class#&gt; *&lt;#object#&gt;;</code><br/><br/>
3.copy：<br/><br/>
<code>@property (nonatomic,copy) NSString *&lt;#string#&gt;;</code><br/>
4.assign：<br/><br/>
<code>@property (nonatomic,assign) &lt;#Class#&gt; &lt;#property#&gt;;</code><br/><br/>
5.delegate：<br/><br/>
<code>@property (nonatomic,weak) id&lt;&lt;#protocol#&gt;&gt; &lt;#delegate#&gt;;</code><br/>
6.block：<br/><br/>
<code>@property (nonatomic,copy) &lt;#Block#&gt; &lt;#block#&gt;;</code><br/><br/>
7.mark：<br/><br/>
<code>#pragma mark &lt;#mark#&gt;</code><br/><br/>
8.ReUseCell：<br/>
```static NSString rid=&lt;#rid#&gt;;  <br/>
 &lt;#Class#&gt; *cell=<a href="">tableView dequeueReusableCellWithIdentifier:rid</a>;  <br/>
 if(cell==nil){  </p>

<p> cell=<a href="">[&lt;#Class#&gt; alloc</a> initWithStyle:UITableViewCellStyleDefault      reuseIdentifier:rid];  <br/>
 }  <br/>
 return cell;<br/>
<code><br/>
9.MainGCD：<br/>
</code><br/>
dispatch_async(dispatch_get_main_queue(), <sup>{  </sup><br/>
&lt;#code#&gt;  <br/>
  });<br/>
<code><br/>
10.AfterGCD：<br/>
</code><br/>
 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(&lt;#delayInSeconds#&gt; * NSEC_PER_SEC)), dispatch_get_main_queue(), <sup>{  </sup><br/>
&lt;#code to be executed after a specified delay#&gt;  <br/>
});<br/>
<code><br/>
11.OnceGCD：<br/>
</code><br/>
 static dispatch_once_t onceToken;  <br/>
 dispatch_once(&amp;onceToken, <sup>{  </sup><br/>
&lt;#code to be executed once#&gt;  <br/>
 });<br/>
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native 集成 Redux]]></title>
    <link href="http://blog.csdn.net/15115315701641.html"/>
    <updated>2017-11-24T21:52:50+08:00</updated>
    <id>http://blog.csdn.net/15115315701641.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">课程介绍</h2>

<ul>
<li>Flux/reFlux/Redux</li>
<li><p>简单/单一状态树</p></li>
<li><p>react 和 redux 数据流的关系</p></li>
<li><p>JS、CSS、HTML</p></li>
<li><p>JSX</p></li>
<li><p>webpack 构建</p></li>
</ul>

<h2 id="toc_1">数据流</h2>

<ul>
<li>MVC 状态复杂之后，action会触发事件 并且不可预测</li>
<li>flux: state Tree will send data to view,but view can&#39;t send data to state-tree.</li>
<li>Redux :  state 是包含在store中的</li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_2">安装</h2>

<pre><code>npm install react
npm install redux react-redux --save
</code></pre>

<h2 id="toc_3">快速开始（速成版本）：</h2>

<h3 id="toc_4">核心概念</h3>

<ul>
<li><code>action</code> : React行为/变化的描述 是一个对象</li>
<li><code>dispatch</code> : 派发用户行为的一个方法 <code>store</code>的一个属性</li>
<li><code>reducer</code> : 接收<code>action</code>,并进行简单的拼接，其内部是<code>纯函数</code>（到底什么是纯函数请移步百度 ： <a href="https://www.baidu.com/s?wd=%E7%BA%AF%E5%87%BD%E6%95%B0">传送门</a> 、 <a href="http://blog.csdn.net/hongweigg/article/details/44035283">速达传送门</a>）</li>
<li><code>store</code> :存储数据的地方</li>
</ul>

<h3 id="toc_5">Get start:</h3>

<ul>
<li><p>step1 : <strong>安装依赖</strong> </p>

<pre><code>npm install redux react-redux --save
</code></pre></li>
<li><p>step2 : 创建一个 AppProvider.js 并导出AppProvider组件 ：  <strong>AppProvider 作为APP的入口组件</strong></p>

<pre><code>export default AppProvider;
</code></pre></li>
<li><p>step3 : AppProvider.js 中导入头文件    </p>

<pre><code>    import { Provider } from &#39;react-redux&#39;;    
    import { createStore } from &#39;redux&#39;;
</code></pre></li>
<li><p>step4 : 准备AppProvider的包装数据：</p>

<ul>
<li><p>创建全局的store用于存储状态,并绑定<strong>reducer</strong></p>

<pre><code>const store = createStore(AppReducer)
</code></pre></li>
<li><p>包装APPProvider：</p>

<pre><code>const AppProvider = () =&gt; {
    return (
      //KR-1 包裹一层Provider   之后进入被包裹控件内部 进行关联处理
        &lt;Provider store={store}&gt;
            &lt;RootStack /&gt;
        &lt;/Provider&gt;
    )
};
</code></pre></li>
<li><p>index.ios.js 文件中注册下 AppProvider对象</p>

<pre><code>AppRegistry.registerComponent(&#39;XinLiFM&#39;, () =&gt; AppProvider);
</code></pre></li>
</ul></li>
<li><p>step5 : <strong>数据绑定</strong> 找到打算有 数据流传递 的对象 AppFind</p>

<ul>
<li><p>导入头文件：</p>

<pre><code>import { connect } from &#39;react-redux&#39;;
</code></pre></li>
<li><p>绑定数据：</p>

<pre><code>//用来获取更新后的数据   监听数据更新
const mapStateToProps = (state,ownProps) =&gt; {
    console.log(state);
    return {
        testShow: state.find.testShow,
     }
}

//用来派发消息
const mapDispatchToProps = (dispatch,ownProps) =&gt; ({
  changeTabBar: (...args) =&gt; dispatch(showTabBar(...args)),
});

//用来进行数据流  和  控件的绑定关系
export default connect(mapStateToProps,mapDispatchToProps)(AppFind)

</code></pre></li>
<li><p>派发消息：</p>

<pre><code>this.props.changeTabBar(!this.props.testShow)
</code></pre></li>
<li><p>消息处理：step4 中绑定的reducer文件中:</p>

<pre><code>//1.导入头文件
import { combineReducers } from &#39;redux&#39;;
//2.创建初始化状态
const initialState = { testShow: true};
//3.逻辑处理
const find = (state = initialState, action) =&gt; {
 switch (action.type) {
        case &#39;findshowTabBar&#39;:{
          return Object.assign({}, state, {
                testShow: action.testShow
            })
        }
        default:
            return state;

    }
}
//4.组合所有的逻辑块
const AppReducer = combineReducers({
    find,
    //如果业务繁多这里可能还有别的模块
});
//5.导出
export default AppReducer;
</code></pre></li>
<li><p>获取更改状态值：</p>

<pre><code>//因为上一步的绑定数据  就是将state的状态值 绑定到AppFind的props上，
//所以取值的时候直接从this。props中取即可
var {testShow,isShowTab,showTabBar} = this.props;
&lt;Text 
    style={{fontSize:17,color:testShow?&quot;red&quot;:&#39;rgb(39, 249, 110)&#39;}}&gt;
    {testShow?&quot;我要显示某个东西&quot;:&quot;我要隐藏某个东西&quot;}
&lt;/Text&gt;
</code></pre></li>
</ul></li>
</ul>

<blockquote>
<p>总结：<br/>
其实这里最重要的就三步：1. 包装   2、数据绑定 3、数据处理</p>
</blockquote>

<h2 id="toc_6">基础</h2>

<h3 id="toc_7">1. action</h3>

<p>信息的携带者。<br/>
<strong>派发消息的几种方式：</strong></p>

<ul>
<li>直接发送：</li>
</ul>

<pre><code>dispatch({type:&#39;action_name&#39;,index:2});

const myAction = {
  type:&#39;action_name&#39;,
  index: 1,
}
dispatch(myAction);
</code></pre>

<ul>
<li>通过Action的创建函数发送：</li>
</ul>

<pre><code>//我们可以把所有的Action封装到一个固定文件 就想CSS文件那样 头文件导入的方式 去引用
const actionFunc = (text) =&gt; {
  return {
    type: &#39;action_name&#39;,
    index: 2,
  }
}

//派发消息时候 直接引用创建函数的返回结果即可
dispatch(actionFunc(&#39;test&#39;));
</code></pre>

<ul>
<li>绑定的Action创建函数</li>
</ul>

<pre><code>//基本action创建函数
const actionFunc = (text) =&gt; {
  return {
    type: &#39;action_name&#39;,
    index: 2,
  }
}
//绑定派发方法
const boundAction = (test) =&gt; {
  dispatch(actionFunc(test));
}

//使用绑定好的派发函数
boundAction(&#39;test&#39;);
</code></pre>

<h3 id="toc_8">2. reducer</h3>

<p>纯函数；</p>

<ul>
<li><p>方法结构</p>

<pre><code>(previouseState,action) =&gt; newState
</code></pre>

<p>给一个旧的state 和一个action 生成 一个新的 state。</p></li>
<li><p>基本方法</p>

<pre><code>const initialState = { testShow: true};

const home = (state = initialState, action) =&gt; {
  switch (action.type) {
    case &#39;homeshowTabBar&#39;:{

      console.log(&quot;homeshowTabBar：%s&quot;,action.testShow);

    //合并状态值
      return Object.assign({}, state, {
        testShow: action.testShow;
      })
    }
    default:
    return state;

  }
}   
</code></pre>

<p>合并state的时候下面的方法也是能达到相同效果的</p>

<pre><code>{...state, ...newState} 
</code></pre></li>
<li><p>拆分合并reducer</p>

<pre><code>const home = (state = initialState, action) =&gt; {
    switch (action.type) {
        case &#39;homeshowTabBar&#39;:{
            console.log(&quot;homeshowTabBar：%s&quot;,action.testShow);
            return Object.assign({}, state, {
                testShow: action.testShow
            })
        }
        default:
        return state;
    }
}

const find = (state = initialState, action) =&gt; {
    switch (action.type) {
        case &#39;findshowTabBar&#39;:{
            return Object.assign({}, state, {
            testShow: action.testShow
            })
        }
        default:
        return state;

    }
}

//合并
const AppReducer = combineReducers({
    nav,
    home,
    find,
});
export default AppReducer
</code></pre>

<p><strong>注意上面的写法和下面完全等价!!!</strong>：</p>

<pre><code>const AppReducer = (state={}, action) =&gt; {
    return {
        home: home(state.home,action),
        find: find(sate.find,action),
    }
}
</code></pre></li>
<li><p>减少代码量 自动定义 reducerCreator</p>

<pre><code>export const testCreator = myCreatorForReducer([], {
 [ActionTypes.ADD_TODO](state, action) {
 let text = action.text.trim();
 return [...state, text];
 }
})

const myCreatorForReducer = (initialState,handles) =&gt; {

    return (state=initialState,action) =&gt; {
        return handles[action.type](state,action);
    }else {
     return state;
    }

}
</code></pre>

<p>设置不同的Key、调用不同的方法:</p>

<pre><code>const reducer = combineReducers({
    a: doSomethingWithA,
    b: processB,
    c: c
})

function reducer(state = {}, action) {
    return {
        a: doSomethingWithA(state.a, action),
        b: processB(state.b, action),
        c: c(state.c, action)
    }
}
</code></pre></li>
</ul>

<h3 id="toc_9">3. store</h3>

<ul>
<li>维持应用的 <code>state</code>；</li>
<li>提供 <code>getState()</code> 方法获取 <code>state</code>；</li>
<li>提供 <code>dispatch(action)</code> 方法更新 <code>state</code>；</li>
<li>通过 <code>subscribe(listener)</code> 注册监听器;</li>
<li>通过 <code>subscribe(listener)</code> 返回的函数注销监听器。</li>
</ul>

<pre><code>import { createStore } from &#39;redux&#39;
import todoApp from &#39;./reducers&#39;
let store = createStore(todoApp)
</code></pre>

<blockquote>
<p>后续会更新的................</p>
</blockquote>

<h2 id="toc_10">高级</h2>

<h3 id="toc_11">异步action</h3>

<h3 id="toc_12">异步数据流</h3>

<h3 id="toc_13">Middleware 中间件</h3>

<h3 id="toc_14">搭配 React Router</h3>

<h2 id="toc_15">技巧</h2>

<h2 id="toc_16">API</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac app 推荐]]></title>
    <link href="http://blog.csdn.net/15115206889632.html"/>
    <updated>2017-11-24T18:51:28+08:00</updated>
    <id>http://blog.csdn.net/15115206889632.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">开发工具篇</h2>

<h3 id="toc_1">Postman</h3>

<p><img src="media/15115206889632/15115207580615.jpg" alt="Postman_Icon"/><br/>
这款APP 最初是 谷歌浏览器的插件...</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SectionListView]]></title>
    <link href="http://blog.csdn.net/14948260667614.html"/>
    <updated>2017-05-15T13:27:46+08:00</updated>
    <id>http://blog.csdn.net/14948260667614.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">属性</h2>

<ol>
<li>ItemSeparatorComponent  <code>{highlighted,leadingItem,leandingSection,section,trailingItem}</code><br/>
返回一个行与行之间的分割组件，不会出现在第一行之前和最后一行之后。

<ul>
<li><code>highlighted</code> 当前行（分割线上面👆的Item）是否是高亮状态</li>
<li><code>leadingItem</code> 当前行分配到的数据源</li>
<li><code>leandingSection</code> 目前我也没搞明白啥意思 这里是<code>undefined</code></li>
<li><code>section</code> 当前段分配到的数据源</li>
<li><code>trailingItem</code> 尾段数据</li>
</ul></li>
<li>ListEmptyCompone  <code>没有接收参数</code><br/>
渲染一个cell为空时的缓冲组件<br/></li>
<li>ListFooterComponent  <code>没有接收参数</code><br/>
渲染整个组件的Footer</li>
<li>ListHeaderComponent   <code>没有接收参数</code><br/>
渲染整个组件的Header</li>
</ol>

<span id="more"></span><!-- more -->

<ol>
<li><p>SectionSeparatorComponent <code>{highlighted,leadingItem,leandingSection,section,trailingItem}</code><br/>
段分割组件</p>

<ul>
<li><code>highlighted</code> 当前行（分割线上面👆的Item）是否是高亮状态</li>
<li><code>leadingItem</code> 当前行分配到的数据源 这里是<code>undefined</code></li>
<li><code>leandingSection</code> 目前我也没搞明白啥意思 这里是<code>undefined</code></li>
<li><code>section</code> 当前段分配到的数据源</li>
<li><code>trailingItem</code> 尾段数据</li>
</ul></li>
<li><p>extraData<br/><br/>
如果有除data以外的数据用在列表中（不论是用在renderItem还是Header或者Footer中），请在此属性中指定。同时此数据在修改时也需要先修改其引用地址（比如先复制到一个新的Object或者数组中），然后再修改其值，否则界面很可能不会刷新。</p></li>
</ol>

<blockquote>
<p>文档说的挺乱，总而言之言而总之：sectionList的刷新首先决定于Data，当Data没变化，但是你想强制刷新UI的时候，有个状态控制，那么这个状态控制需要在这里写一下，关联一下，否则你的这个状态不会被关联，UI不会被刷新。</p>
</blockquote>

<ol>
<li><p>initialNumToRender<br/><br/>
指定一开始渲染的item 数量,预加载item 数</p></li>
<li><p>keyExtractor <code>(item: ItemT, index: number) =&gt; string</code><br/>
此函数用于为<strong>给定的item</strong>生成一个不重复的key。Key的作用是使React能够区分同类元素的不同个体，以便在刷新时能够确定其变化的位置，减少重新渲染的开销。若不指定此函数，则默认抽取item.key作为key值。若item.key也不存在，则使用数组下标。</p></li>
<li><p>onEndReachedThreshold  <code>number</code><br/><br/>
数值。决定当距离内容最底部还有多远时触发onEndReached回调。注意此参数是一个比值而非像素单位。比如，0.5表示距离内容最底部的距离为当前列表可见长度的一半时触发</p></li>
<li><p>onEndReached  <code>(info: {distanceFromEnd: number}) =&gt; void</code></p>

<p>传入一个对象info，info包含number类型的<code>distanceFromEnd</code>属性。</p></li>
<li><p>onViewableItemsChanged <code>(info: {viewableItems: Array&lt;ViewToken&gt;, changed: Array&lt;ViewToken&gt;}) =&gt; void</code></p>

<ul>
<li>viewableItems 可是Item对应的数据</li>
<li>changed 改变的数据<br/>
可视元素发生变化时调用<br/></li>
</ul></li>
<li><p>refreshing <code>boolean</code><br/><br/>
等待新数据加载时此属性设置为true，列表会显示出正在加载的符号</p></li>
<li><p>renderItem  <code>(info: {item: Item, index: number}) =&gt; ?React.Element&lt;any&gt;</code><br/><br/>
渲染每一个section中的item    </p>

<ul>
<li>item 每个item渲染所需数据</li>
<li>index item在其section中的位置索引</li>
</ul></li>
<li><p>renderSectionHeader?: <code>{section: SectionT}</code><br/>
接收一个对象，这个对象包含<code>section</code>属性，<br/>
返回一个组件，用作段头    </p></li>
<li><p>sections <code>ReadOnlyArray&lt;SectionT&gt;</code></p>

<p>传入一个sections数组<br/>
<code><br/>
[<br/>
{data:[{name:&#39;nader&#39;},{name:&#39;chris&#39;}],key:&#39;A&#39;},<br/>
{data:[{name:&#39;nick&#39;},{name:&#39;amanda&#39;}],key:&#39;B&#39;},<br/>
{data:[{name:&#39;nick&#39;},{name:&#39;amanda&#39;}],key:&#39;C&#39;},<br/>
{data:[{name:&#39;nick&#39;}],key:&#39;D&#39;},<br/>
]<br/>
</code></p></li>
<li><p>stickySectionHeadersEnabled <code>boolean</code></p></li>
</ol>

<h2 id="toc_1">方法</h2>

<ul>
<li><code>scrollToLocation (params: object)</code> -- {sectionIndex,itemIndex}:代码控制 UI交互跳转到指定位置</li>
<li><code>recordInteraction()</code> 告诉ListView 交互已经发生了</li>
<li><code>flashScrollIndicators()</code>显示指示滚动</li>
</ul>

]]></content>
  </entry>
  
</feed>
