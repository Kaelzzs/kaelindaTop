<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[kaelinda]]></title>
  <link href="http://blog.csdn.net/atom.xml" rel="self"/>
  <link href="http://blog.csdn.net/"/>
  <updated>2018-03-21T23:19:52+08:00</updated>
  <id>http://blog.csdn.net/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="http://blog.csdn.net/15200726964422.html"/>
    <updated>2018-03-03T18:24:56+08:00</updated>
    <id>http://blog.csdn.net/15200726964422.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 离屏渲染]]></title>
    <link href="http://blog.csdn.net/15200715202464.html"/>
    <updated>2018-03-03T18:05:20+08:00</updated>
    <id>http://blog.csdn.net/15200715202464.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">触发方式</h2>

<p>设置以下方式会触发离屏渲染：</p>

<ul>
<li>shouldRasterize（光栅化）</li>
<li>masks（遮罩）</li>
<li>shadows（阴影）</li>
<li>edge antialiasing（抗锯齿）</li>
<li>group opacity（不透明）</li>
<li>复杂形状设置圆角等</li>
<li>渐变 </li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 面试题总结]]></title>
    <link href="http://blog.csdn.net/15198022156700.html"/>
    <updated>2018-02-28T15:16:55+08:00</updated>
    <id>http://blog.csdn.net/15198022156700.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">基础篇</h2>

<h3 id="toc_1">内存管理 ：assign copy strong weak...</h3>

<ul>
<li>简述OC中内存管理机制,与retain配对使用的方法是dealloc还是release，为什么？</li>
</ul>

<blockquote>
<p>管理机制：<br/>
  使用了一种叫做 <strong>引用计数</strong> 的机制来管理内存中的对象。OC中每个对象都对应着他们自己的引用计数，引用计数可以理解为一个整数计数器，当使用alloc方法创建对象的时候，持有计数会自动设置为1。当你向一个对象发送retain消息 时，持有计数数值会增加1。相反，当你像一个对象发送release消息时，持有计数数值会减小1。当对象的持有计数变为0的时候，对象会释放自己所占用的内存</p>
</blockquote>

<ul>
<li><p>修饰词的作用</p>

<ul>
<li>retain(引用计数加1)-&gt;release（引用计数减1）</li>
<li>alloc（申请内存空间）-&gt;dealloc(释放内存空间)</li>
<li>readwrite: 表示既有getter，也有setter   (默认)</li>
<li>readonly: 表示只有getter，没有setter</li>
<li>nonatomic:不考虑线程安全</li>
<li>atomic:线程操作安全   （默认）</li>
<li>retain: release旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1</li>
<li>assign: 简单赋值，不更改索引计数    （默认）</li>
<li>copy: 其实是建立了一个相同的对象,地址不同（retain：指针拷贝  copy：内容拷贝）</li>
<li>strong:（ARC下的）和（MRC）retain一样    （默认）</li>
<li>weak:（ARC下的）和（MRC）assign一样， weak当指向的内存释放掉后自动nil化，防止野指针</li>
<li>unsafe_unretained 声明一个弱引用，但是不会自动nil化，也就是说，如果所指向的内存区域被释放了，这个指针就是一个野指针了。 autoreleasing 用来修饰一个函数的参数，这个参数会在函数返回的时候被自动释放。
### .类变量的@protected ,@private,@public,@package，声明各有什么含义？</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 项目组件化]]></title>
    <link href="http://blog.csdn.net/15193944679783.html"/>
    <updated>2018-02-23T22:01:07+08:00</updated>
    <id>http://blog.csdn.net/15193944679783.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">组件化需要解决的问题</h2>

<ul>
<li>APP 如何跳到任意指定界面（APP外部跳转，APP内部跳转）</li>
<li>自家APP之间如何相互跳转 </li>
<li>如何降低APP组件和APP界面之间的耦合度</li>
<li>如何动态下发配置文件；iOS 安卓共用配置文件</li>
<li>AOP统计界面跳转</li>
<li>组件之间通信，组件和界面之间通信</li>
</ul>

<h2 id="toc_1">组件化步骤</h2>

<ul>
<li>拆分UI组件</li>
<li>拆分业务组件</li>
<li>组件管理</li>
<li>组件通信</li>
</ul>

<h2 id="toc_2">组件化架构 &amp;&amp; 思路</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS APP性能优化方向分析]]></title>
    <link href="http://blog.csdn.net/15193931556096.html"/>
    <updated>2018-02-23T21:39:15+08:00</updated>
    <id>http://blog.csdn.net/15193931556096.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">网络性能</h2>

<ul>
<li>减少不必要的网络请求</li>
<li>server端数据查询算法优化</li>
<li>DNS解析</li>
</ul>

<h2 id="toc_1">内存性能</h2>

<ul>
<li>各种循环引用 导致内存泄漏</li>
<li>Core Animation 对象手动释放</li>
<li>UIWebView 内存泄漏</li>
</ul>

<h2 id="toc_2">主线程阻塞</h2>

<ul>
<li>网络同步请求</li>
<li>I/O操作</li>
<li>大量运算</li>
<li>解压、压缩
...</li>
</ul>

<h2 id="toc_3">离屏渲染</h2>

<p>离屏渲染：GPU在当前缓存区之外另外的去开辟空间进行渲染，同样的一帧图片 会被渲染两次甚至多次</p>

<p>：uiview.layer.cornerRadius 系统方法切圆角---&gt;&gt;解决方案：Runtime + 画图</p>

<h2 id="toc_4">图片处理</h2>

<ul>
<li>imageWithName：加载到缓存中可重复使用</li>
<li>initWithContentsOfFile: 加载一次不会存到缓存中</li>
</ul>

<h2 id="toc_5">其他</h2>

<ul>
<li>加速启动</li>
<li>避免日期格式的转换</li>
</ul>

<h3 id="toc_6">优化瀑布流中 网络图片 加载导致UI卡顿问题</h3>

<blockquote>
<p>1、异步下载图片<br/>
2、异步加载图片成二进制 NSData  （<strong>这一步是关键</strong>） <br/>
3、UIImageView 加载二进制形式的NSData</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[源码阅读 -- YYModel （一）]]></title>
    <link href="http://blog.csdn.net/15181411526837.html"/>
    <updated>2018-02-09T09:52:32+08:00</updated>
    <id>http://blog.csdn.net/15181411526837.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DLNA DMR]]></title>
    <link href="http://blog.csdn.net/15174544275720.html"/>
    <updated>2018-02-01T11:07:07+08:00</updated>
    <id>http://blog.csdn.net/15174544275720.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">CGUpnpAvRenderer</h2>

<pre><code>#if !defined(_CG_CLINKCAV_MEDIARENDERER_H_)
typedef void CgUpnpAvRenderer;
#endif

/**
 * The CGUpnpAvRenderer class is a UPnP/AV media server class.
 */
@interface CGUpnpAvRenderer : CGUpnpDevice
{
    CgUpnpAvRenderer *cAvObject;
}
@property(readonly) CgUpnpAvRenderer *cAvObject;
- (id)init;
- (id)initWithCObject:(CgUpnpDevice *)cobj;
- (BOOL)setAVTransportURI:(NSString *)aURI;
- (BOOL)play;
- (BOOL)stop;
- (BOOL)pause;
- (BOOL)next;
- (BOOL)previous;
- (BOOL)seek:(float)absTime;
- (BOOL)isPlaying;
/*
- (BOOL)start
- (BOOL)stop
*/
- (CGUpnpAVPositionInfo *)positionInfo;
</code></pre>

<h2 id="toc_1">CGUpnpDevice</h2>

<pre><code>/**
 * The CGUpnpDevice class is a wrapper class for CgUpnpDevice of CyberLink for C.
 */
// 设备包装类
@protocol CGUpnpDeviceDelegate &lt;NSObject&gt;
@optional
// 收到Action的协议方法
- (BOOL)device:(CGUpnpDevice *)device service:(CGUpnpService *)service actionReceived:(CGUpnpAction *)action;
@end

/**
 * The CGUpnpDevice class is a wrapper class for CgUpnpDevice of CyberLink for C.
 */
@interface CGUpnpDevice : NSObject 
{
    BOOL isCObjectCreated;
}
@property(assign) CgUpnpDevice *cObject;
@property(assign) id&lt;CGUpnpDeviceDelegate&gt; delegate;
/**
 * Create a new UPnP device.
 * 
 * @return New instance if successfull; otherwise nil.
 */
 // 初始化方法 创建一个新的UPnP设备
- (id) init;
/**
 * Create a new UPnP device with the C instance.
 * 
 * @return New instance if successfull; otherwise nil.
 */
 // 用一个设备初始化另一设备
- (id) initWithCObject:(CgUpnpDevice *)cobj;
/**
 * Create a new UPnP device with the XML descriptioin.
 * 
 * @return New instance if successfull; otherwise nil.
 */
 // xml  创建设备
- (id) initWithXMLDescription:(NSString *)xmlDesc;
/**
 * Parse the specified XML description.
 * 
 * @return YES if successfull; otherwise nui.
 */
- (BOOL) parseXMLDescription:(NSString *)xmlDesc;
/**
 * Get the friendly name of the device.
 * 
 * @return Friendly name.
 */
// 获取友好的名字
- (NSString *)friendlyName;
/**
 * Get the device type of the device.
 * 
 * @return Device Type.
 */
 // 设备类型
- (NSString *)deviceType;
/**
 * Get the UDN of the device.
 * 
 * @return UDN of the specified device.
 */
 // 获取设备的UDN
- (NSString *)udn;
/**
 * Return a manufacture.
 *
 * @return Manufacture of the device.
 */
 // 制造商
- (NSString *)manufacturer;

/**
 * Return a model number.
 *
 * @return Model number of the device.
 */
 // 返回模型数
- (NSString *)modelNumber;

/**
 * Return a model name.
 *
 * @return Model name of the device.
 */
 // 返回模型名
- (NSString *)modelName;

/**
 * Return a urlBase
 *
 * @return URLBase of the device.
 */
 // 返回设备的URLBase
- (NSString *)urlBase;
/**
 * Return a descrition URL
 *
 * @return Descripton URL of the device.
 */
 // 返回设备URL描述
- (NSString *)descriptionURL;
/**
 * Return a location URL
 *
 * @return Location URL of the device.
 */
 // 返回一个本地URL
- (NSString *)locationURL;
/**
 * Set a device type of the device.
 * 
 * @param aType Device type to set.
 */
 // 设置设备类型
-(void)setDeviceType:(NSString *)aType;
/**
 * Set a friendly name of the device.
 * 
 * @param aName Friendly name to set.
 */
 // 设置友好名称
-(void)setFriendlyName:(NSString *)aName;
/**
 * Set a udn of the device.
 * 
 * @param aUdn UDN to set.
 */
-(void)setUdn:(NSString *)aUdn;
/**
 * Check whether the device type is the specified type.
 *
 * @param aType A type string of the device.
 * 
 * @return YES if the specified type is same as the device type; otherwise NO.
 */
- (BOOL)isDeviceType:(NSString *)aType;
/**
 * Check whether the device&#39;s UDN is the specified UDN.
 *
 * @param aUDN A UDN string of the device.
 * 
 * @return YES if the specified UDN is same as the device&#39; UDN; otherwise NO.
 */
- (BOOL)isUDN:(NSString *)aUDN;
/**
 * Check whether the device&#39;s friendly name is the specified name.
 *
 * @param aFriendlyName A friendly name string of the device.
 * 
 * @return YES if the specified friendly name is same as the device&#39; friendly name; otherwise NO.
 */
- (BOOL)isFriendlyName:(NSString *)aFriendlyName;
/**
 * Return a presentationURL
 *
 * @return presentationURL of the device.
 */
- (NSString *)presentationURL;
/**
 * Get all services in the device as a NSArray object. The array has the services as instances of CGUpnpService.
 *
 * @return NSArray of CGUpnpService.
 */
 // 返回设备CGUpnpService服务组
- (NSArray *)services;
/**
 * Get a service in the device by the specified service ID.
 *
 * @param serviceId A service ID string of the service.
 *
 * @return The CGUpnpService if the specified service is found; otherwise nil.
 */
 // 根据seviceID 获取服务对象
- (CGUpnpService *)getServiceForID:(NSString *)serviceId;
/**
 * Get a service in the device by the specified service type.
 *
 * @param serviceType A service type string of the service.
 *
 * @return The CGUpnpService if the specified service is found; otherwise nil.
 */
 // 根据类型获取服务对象 service
- (CGUpnpService *)getServiceForType:(NSString *)serviceType;
/**
 * Get all icons in the device as a NSArray object. The array has the services as instances of CGUpnpIconIcon.
 *
 * @return NSArray of CGUpnpIcon.
 */
 // 获取所有图标
- (NSArray *)icons;
/**
 * Start the device.
 *
 * @return YES if the device is started normally, otherwise NO.
 */
- (BOOL)start;
/**
 * Stop the device.
 *
 * @return YES if the device is started normally, otherwise NO.
 */
- (BOOL)stop;
/**
 * Check if the controll point is running.
 *
 * @return YES if the device is started normally, otherwise NO.
 */
 //检查控制点 DMC是否在运行
- (BOOL)isRunning;
/**
 * Announce the device.
 *
 * @return YES if the device is started normally, otherwise NO.
 */
 // 广播这个设备
- (BOOL)announce;
/**
 * Set a user data.
 *
 * @param aUserData A user data to set.
 *
 * @return The CGUpnpService if the specified service is found; otherwise nil.
 */
 // 设置用户数据
- (void)setUserData:(void *)aUserData;
/**
 * Get a stored user data.
 *
 * @return A stored user data.
 */
 获取已存储的用户数据
- (void *)userData;
/**
 * Return a IP address.
 *
 * @return IP address of the device.
 */
 // 获取IP地址
- (NSString *)ipaddress;
/**
 * Return a most smallest icon.
 *
 * @return Smallest Icon.
 */
 // 获取一个最小的 icon
- (CGUpnpIcon *)smallestIcon;
/**
 * Return a most smallest icon with a specified mime type.
 *
 * @return Smallest Icon.
 */
 // 获取指定类型的icon
- (CGUpnpIcon *)smallestIconWithMimeType:(NSString *)mimeType;
/**
 * Return a absolute url of the specified icon.
 *
 * @param anIcon Icon.
 *
 * @return Absolute url of the specified icon.
 */
 // 获取icon的绝对路径
- (NSString *)absoluteIconUrl:(CGUpnpIcon *)anIcon;
</code></pre>

<h2 id="toc_2">CGUpnpStateVariable</h2>

<pre><code>#if !defined(_CG_UPNP_CSTATEVARIABLE_H_)
typedef void CgUpnpStateVariable;
#endif

/**
 * The CGUpnpStateVariable class is a wrapper class for CgUpnpStateVariable of CyberLink for C.
 */
@interface CGUpnpStateVariable : NSObject 
{
    CgUpnpStateVariable *cObject;
}
@property(readonly) CgUpnpStateVariable *cObject;
- (id)initWithCObject:(CgUpnpStateVariable *)cobj;
/**
 * Get the name of the state variable.
 * 
 * @return The name.
 */
 // 状态名
- (NSString *)name;
/**
 * Get the value of the state variable.
 * 
 * @return The value.
 */
 // 状态值
- (NSString *)value;

/**
 * Get an array of the allowed values for the state variable
 * 
 * @return The array.
 */
 // 允许的所有状态值
- (NSArray *)allowedValues;

/**
 * Checks whether value is allowed for this state variable
 *
 * @param value to be checked
 *
 * @return YES if true
 */
 // 检测状态值是否是被允许的
- (BOOL)isAllowedValue:(NSString*)value;

/**
 * Send query
 *
 * @return YES if successfull; otherwise NO
 */
- (BOOL)query;
/**
 * Get a states code of the last query. 
 *
 * @return The status code
 */
- (NSInteger)statusCode;
</code></pre>

<h2 id="toc_3">CGUpnpIcon</h2>

<pre><code>/**
 * The CGUpnpIcon class is a wrapper class for CgUpnpIcon of CyberLink for C.
 */
@interface CGUpnpIcon : NSObject
{
    CgUpnpIcon *cObject;
#if defined(TARGET_OS_IPHONE)
    NSString *resourceName;
#endif
}
@property(readonly) CgUpnpIcon *cObject;
#if defined(TARGET_OS_IPHONE)
@property(readonly) NSString *resourceName;
#endif
- (id)initWithCObject:(CgUpnpIcon *)cobj;
/**
 * Get the url of the icon.
 * 
 * @return The url.
 */
- (NSString *)url;
/**
 * Get the url of the width.
 * 
 * @return The width.
 */
- (NSInteger)width;
/**
 * Get the height of the icon.
 * 
 * @return The height.
 */
- (NSInteger)height;
/**
 * Get the depth of the icon.
 * 
 * @return The depth.
 */
- (NSInteger)depth;
#if defined(TARGET_OS_IPHONE)
- (void)setResourceName:(NSString *) aResourceName;
#endif
</code></pre>

<h2 id="toc_4">CGUpnpAVPositionInfo</h2>

<pre><code>@property(retain) CGUpnpAction *upnpAction;
-(id)initWithAction:(CGUpnpAction *)aUpnpAction;
-(float)trackDuration;
-(float)absTime;
-(float)relTime;
@end

@interface NSString(CGUPnPAV)
// 总时长字符串
+(NSString *)stringWithDurationTime:(float)timeValue;
// 总时长
- (float)durationTime;
</code></pre>

<h2 id="toc_5">CGUpnpAction</h2>

<pre><code>@interface CGUpnpAction : NSObject 
{
    CgUpnpAction *cObject;
}
@property(readonly) CgUpnpAction *cObject;
- (id)initWithCObject:(CgUpnpAction *)cobj;
/**
 * Get the name of the action.
 * 行为名称
 * @return The name.
 */
- (NSString *)name;
/**
 * Get all arguments in the action as a NSDictionary object.
 * 获取所有行为对象中的参数
 * @return NSDictionary of the arguments.
 */
- (NSDictionary *)arguments;
/**
 * Set a value of the specified argument from the action by the argument&#39;s name directly.
 * 通过name给指定action设置参数
 * @param value The value to set
 * @param name The name of the argument to look for
 * @return YES if successfull; otherwise NO
 */
- (BOOL)setArgumentValue:(NSString *)value forName:(NSString *)name;
/**
 * Get a value of the specified argument from the action by the argument&#39;s name directly.
 * 通过action参数名 获取action参数值
 * @param name The name of the argument to look for
 * @return The target value if successfull; otherwise NULL
 */
- (NSString *)argumentValueForName:(NSString *)name;
/**
 * Send action
 * 发送Action
 * @return YES if successfull; otherwise NO
 */
- (BOOL)post;
/**
 * Send action
 * 发送action 携带指定参数
 * @param arguments Arguments to set
 *
 * @return YES if successfull; otherwise NO
 */
- (BOOL)postWithArguments:(NSDictionary *)arguments;
/**
 * Get a states code of the last post. 
 * 获取最后POST的状态码
 * @return The status code
 */
- (NSInteger)statusCode;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DLNA DMC]]></title>
    <link href="http://blog.csdn.net/15173790393385.html"/>
    <updated>2018-01-31T14:10:39+08:00</updated>
    <id>http://blog.csdn.net/15173790393385.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">CGUpnpControlPoint</h2>

<pre><code>
#if !defined(_CG_UPNP_CCONTROLPOINT_H_)
typedef void CgUpnpControlPoint;
#endif

@class CGUpnpDevice;
@class CGUpnpControlPoint;

@protocol CGUpnpControlPointDelegate &lt;NSObject&gt;
@optional
// deviceUdn 设备的UDID 设备添加，更新，移除，失效的协议方法
- (void)controlPoint:(CGUpnpControlPoint *)controlPoint deviceAdded:(NSString *)deviceUdn;
- (void)controlPoint:(CGUpnpControlPoint *)controlPoint deviceUpdated:(NSString *)deviceUdn;
- (void)controlPoint:(CGUpnpControlPoint *)controlPoint deviceRemoved:(NSString *)deviceUdn;
- (void)controlPoint:(CGUpnpControlPoint *)controlPoint deviceInvalid:(NSString *)deviceUdn;
@end

/**
 * The CGUpnpControlPoint class is a wrapper class for CgUpnpControlPoint of CyberLink for C to 
 * program using only Objective-C directly on MacOSX.
 * Currently, the only basic methods are wrapped to control UPnP devices.
 */
@interface CGUpnpControlPoint : NSObject 
{
    CgUpnpControlPoint *cObject;
}
// 子控制点
@property(readonly) CgUpnpControlPoint *cObject;
// 代理对象
@property(assign) id&lt;CGUpnpControlPointDelegate&gt; delegate;

// get方法
- (CgUpnpControlPoint *)cObject;
/**
 * Activate some background threads of the control point such as SSDP and 
 * HTTP servers to listen messages and events of UPnP. You must call this 
 * method before you can actually use a control point.
 *
 * @return TRUE if successful; otherwise FALSE
 *
 */
 // 激活DMC的子线程 SSDP HTTP服务，去监听UPnP信息和时间
 // 使用控制点之前必须要激活
- (BOOL)start;
/**
 * Stop some background threads of the control point such as SSDP and 
 * HTTP servers to listen messages and events of UPnP. 
 *
 * @return TRUE if successful; otherwise FALSE
 *
 */
 // 停止后台线程 和 SSDP HTTP 服务
- (BOOL)stop;
/**
 * Check if the controll point is running.
 *
 * @return YES if the device is started normally, otherwise NO.
 */
 // 检测DMC是否正在运行
- (BOOL)isRunning;
/**
 * Send a M-SEARCH request to find for the all UPnP devices of UPnP in the network.
 * The method waits for the specified MX time. Use setSsdpSearchMX:(NSInteger)aMX to change the time.
 * The method is same as searchWithST() when the ST parameter is &quot;ssdp:all&quot;.
 */
 
 // 发送M-SEARCH 请求去发现局域网内所有的UPnP设备
- (void)search;
/**
 * Send a M-SEARCH request to find for the specified UPnP devices by a ST parameter in the network.
 * The method waits for the specified MX time. Use setSsdpSearchMX:(NSInteger)aMX to change the time.
 *
 * @param aST The Search Target parameter (ex. &quot;ssdp:all&quot;)
 */
- (void)searchWithST:(NSString *)aST;
/**
 * Set a MX parameter used for SSDP searches in seconds.
 * The parameter is used to wait for M-SEARCH responses in search() and searchWithST:(NSString *)aST.
 *
 * @param aMX Time to wait
 */
- (void)setSsdpSearchMX:(NSInteger)aMX;
/**
 * Get a MX parameter used for SSDP searches in seconds.
 * The parameter is used to wait for M-SEARCH responses in search() and searchWithST:(NSString *)aST.
 *
 * @return Time to wait
 */
// 等待时间
- (NSInteger)ssdpSearchMX;
/**
 * Get all UPnP devices which the control point found as a NSArray object. The array has the devices as instances of CGUpnpDevice.
 * @return NSArray of CGUpnpDevice.
 */
 // DMC发现的所有设备
- (NSArray *)devices;
/**
 * Get a specified UPnP devices by the UDN.
 * @return CGUpnpDevice when the specified device is found, otherwise nil.
 */
 // 通过UDN 获取指定的upnp设备
- (CGUpnpDevice *)deviceForUDN:(NSString *)udn;
</code></pre>

<h2 id="toc_1">CGUpnpAvContentDirectory</h2>

<pre><code>/**
 * The CGUpnpAvContentDirectory class has UPnP/AV objects of a media servers.
 *
 */
@interface CGUpnpAvContentDirectory : NSObject
{
    CGUpnpAvContentManager *contentMgr;
}
- (CGUpnpAvContainer *)rootObject;
- (CGUpnpAvObject *)objectForId:(NSString *)aObjectId;
- (CGUpnpAvObject *)objectForTitlePath:(NSString *)aTitlePath;
@end
</code></pre>

<h2 id="toc_2">CGUpnpAvContentManager</h2>

<pre><code>/**
 * The CGUpnpAvContentDirectory class has UPnP/AV objects of a media servers.
 *
 */
@interface CGUpnpAvContentManager : NSObject
{
    CGUpnpAvRoot *rootObj;
}
- (CGUpnpAvContainer *)rootObject;
- (CGUpnpAvObject *)objectForId:(NSString *)aObjectId;
- (CGUpnpAvObject *)objectForTitlePath:(NSString *)aTitlePath;
</code></pre>

<h2 id="toc_3">CGUpnpAvObject</h2>

<pre><code>
/**
 * The CGUpnpAvObject class is a wrapper class for CgUpnpAvObject of CyberLink for C.
 */

#define CGUPNPAV_OBJECT_MOVIE_FILEEXT @&quot;mov&quot;
#define CGUPNPAV_OBJECT_SOUND_FILEEXT @&quot;snd&quot;
#define CGUPNPAV_OBJECT_IMAGE_FILEEXT @&quot;img&quot;

@interface CGUpnpAvObject : CGXmlNode 
{
    // 父类对象
    CGUpnpAvObject *parent;
}
@property(retain) id userObject;
#if defined(TARGET_OS_IPHONE)
@property(retain) UIImage *thumbnailImage;
#endif

// xml字符串转成对象
+ (NSArray *)arrayWithXMLString:(NSString *)aXmlString;
// 初始化方法
- (id)init;
#if  !defined(TARGET_OS_IPHONE)
- (id)initWithXMLNode:(NSXMLElement *)aXmlNode;
#else
- (id)initWithXMLNode:(CgXmlNode *)aXmlNode;
- (id)initWithMediaContent:(CgUpnpAvContent *)aMediaContent;
#endif
// 判断方法
- (BOOL)isEqual:(id)anObject;
- (BOOL)isContainer;
- (BOOL)isItem;
// 设置、获取父亲类
- (void)setParent:(CGUpnpAvObject *)aParent;
- (CGUpnpAvObject *)parent;
// 祖先类对象
- (CGUpnpAvObject *)ancestor;
// 对象ID
- (NSString *)objectId;
// 子类对象个数
- (NSUInteger)childCount;
// 标题（文件名 不带后缀）
- (NSString *)title;
// upnp 类型
- (NSString *)upnpClass;
// 日期
- (NSString *)date;
// 相册URI
- (NSString *)albumArtURI;
// 设置对象ID、title等
- (void)setObjectId:(NSString *)aValue;
- (void)setTitle:(NSString *)aValue;
- (void)setUpnpClass:(NSString *)aValue;
// 是否包含某一资源对象
- (BOOL)isObjectId:(NSString *)aObjectId;
- (BOOL)isTitle:(NSString *)aTitle;
- (BOOL)isUpnpClass:(NSString *)aUpnpClass;
// 文件全名 （带后缀）
- (NSString *)toFileNameString;
// 艺术家 作者
- (NSString *)artist;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DLNA DMS]]></title>
    <link href="http://blog.csdn.net/15173774932057.html"/>
    <updated>2018-01-31T13:44:53+08:00</updated>
    <id>http://blog.csdn.net/15173774932057.html</id>
    <content type="html"><![CDATA[
<p>上源码：</p>

<pre><code>#if defined(TARGET_OS_IPHONE)
#import &lt;UIKit/UIKit.h&gt;
#else
#import &lt;Foundation/NSArray.h&gt;
#import &lt;Foundation/NSString.h&gt;
#endif

#import &lt;CyberLink/UPnP.h&gt;

@class CGUpnpAvContentDirectory;
@class CGUpnpAvObject;
@class CGUpnpAvContainer;
@class CGUpnpAvServer;

#if !defined(_CG_CLINKCAV_SERVER_H_)
typedef void CgUpnpAvServer;
#endif

@protocol CGUpnpAvServerDelegate &lt;NSObject&gt;
@optional
- (void)upnpAvServer:(CGUpnpAvServer *)upnpAvServer browse:(CGUpnpAction *)browseAction avObject:(CGUpnpAvObject *)avObject;
- (void)upnpAvServer:(CGUpnpAvServer *)upnpAvServer search:(CGUpnpAction *)searchAction avObject:(CGUpnpAvObject *)avObject;
@end

/**
 * The CGUpnpAvServer class is a UPnP/AV media server class.
 * 这个 CGUpnpAvServer 类是UPnP/AV 谜题资源服务类
 */
@interface CGUpnpAvServer : CGUpnpDevice
{
}

@property(readonly) CGUpnpAvContentDirectory *contentDirectory;
// DMS 可以持有子服务作为属性
@property(readonly) CgUpnpAvServer *cAvObject;
// 设置代理
@property(assign) id&lt;CGUpnpAvServerDelegate&gt; delegate;

#if defined(TARGET_OS_IPHONE)
@property(retain) UIImage *thumbnailImage;
#endif

/*
 * Create a new UPnP/AV server.
 * 
 * @return New instance if successfull; otherwise nil.
 */
- (id)init;
/**
 * Create a new UPnP/AV server with the C instance.
 * 
 * @return New instance if successfull; otherwise nil.
 */
- (id)initWithCObject:(CgUpnpDevice *)cobj;
- (void)setUserObject:(id)aUserObj;
- (id)userObject;
// 浏览某一个CGUpnpAvObject 的ID 是否成功
- (BOOL)browse:(NSString *)aObjectId browseFlag:(NSString *)aBrowseFlag options:(NSDictionary *)options;
// 浏览二进制
- (CGUpnpAvObject *)browseMetadata:(NSString *)aObjectId;
// 所有子对象个数
- (NSArray *)browseDirectChildren:(NSString *)aObjectId;
// 获取指定个数的子对象
- (NSArray *)browseDirectChildren:(NSString *)aObjectId requestedCount:(NSUInteger) aRequestedCount;
// 获取指定个数的子对象
- (NSArray *)browseDirectChildren:(NSString *)aObjectId requestedCount:(NSUInteger)aRequestedCount startingIndex:(NSUInteger)aStartingIndex;
// 浏览行为
- (CGUpnpAction *)browseAction;
// 查找某个东西
- (NSArray *)search:(NSString *)aSearchCriteria;
// 同上
- (NSArray *)searchByBrowse:(NSString *)aSearchCriteria;
- (NSArray *)searchByBrowse:(NSString *)aSearchCriteria objectId:(NSString *)objectId;
// 查找UPnPAction
- (CGUpnpAction *)searchAction;
// 跟对象 （对象可以持有别的对象作为属性）
- (CGUpnpAvContainer *)rootObject;
// 通过ID获取AVObject
- (CGUpnpAvObject *)objectForId:(NSString *)aObjectId;
// 通过titlePath 获取AVObject对象
- (CGUpnpAvObject *)objectForTitlePath:(NSString *)aTitlePath;
// 开始
- (BOOL)start;
// 停止
- (BOOL)stop;
// 锁定
- (void)lock;
// 解锁
- (void)unlock;
@end
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS设备上实现DLNA功能 Platinum 篇]]></title>
    <link href="http://blog.csdn.net/15172908985351.html"/>
    <updated>2018-01-30T13:41:38+08:00</updated>
    <id>http://blog.csdn.net/15172908985351.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">DLNA 相关</h2>

<ul>
<li>DLNA</li>
<li>Miracast</li>
<li>Airplay</li>
</ul>

<p>网络环境：同一个网关下，即同一个局域网的同一网段</p>

<h3 id="toc_1">基本名词解释</h3>

<ul>
<li>DLNA全称： DIGITAL LIVING NETWORK ALLIANCE(数字生活网络联盟)</li>
<li>宗旨： Enjoy your music, photos and videos, anywhere anytime</li>
<li>协议： DLNA包含若干协议和标准，最重要的也是我们最常用的就是UPnP技术</li>
<li>通用即插即用 (UPnP) 是一种用于 PC 机和智能设备（或仪器）的常见对等网络连接的体系结构，尤其是在家庭中。UPnP 以 Internet 标准和技术（例如 TCP/IP、HTTP 和 XML）为基础，使这样的设备彼此可自动连接和协同工作，从而使网络（尤其是家庭网络）对更多的人成为可能</li>
</ul>

<h3 id="toc_2">技术名词解释</h3>

<ul>
<li>DMC：控制点</li>
<li>DMS：资源服务器</li>
<li>DMR：渲染器</li>
</ul>

<h3 id="toc_3">发现设备</h3>

<p>智能终端设备加入组网，搜索其他设备的基本流程。当一个新的DMC加入局域网，为了获取当前网段里有哪些智能设备，需要遵循<code>SSDP</code>向默认的多播IP和端口发送获取信息的请求。对于<code>DMC</code> 可以使用DLNA定义的 <code>搜索响应方式</code> 来发现设备，这会用到HTTP的扩展协议<code>M-SEARCH</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从零开始学习使用 vuex]]></title>
    <link href="http://blog.csdn.net/15168925544178.html"/>
    <updated>2018-01-25T23:02:34+08:00</updated>
    <id>http://blog.csdn.net/15168925544178.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>本文是建立在，对vuex理论有一定理解的基础上写的。<br/>
因为官方文档的写法是 针对 有一定的vue开发经验 和 JavaScript 有一定理解的开发者看的，对于小白级别的我来说，理解起来有一定困难。所以，唯一想我一向的小白想尽快上手vuex....</p>
</blockquote>

<p><a href="https://vuex.vuejs.org/zh-cn/installation.html">详情请参考vuex官方文档</a></p>

<h2 id="toc_0">安装</h2>

<h3 id="toc_1">直接下载 CDN 安装</h3>

<p>CDN 链接地址：<code>https://unpkg.com/vuex</code><br/>
指定到固定版本：<code>https://unpkg.com/vuex@2.0.0</code></p>

<pre><code>&lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/path/to/vuex.js&quot;&gt;&lt;/script&gt;
</code></pre>

<h3 id="toc_2">npm 方式安装 （推荐！简单快捷，便于管理）</h3>

<p><code>npm install -save vuex</code></p>

<h3 id="toc_3">yar</h3>

<p><code>yarn add vuex</code></p>

<h3 id="toc_4">自己构建</h3>

<pre><code class="language-bash">git clone https://github.com/vuejs/vuex.git node_modules/vuex
cd node_modules/vuex
npm install
npm run build
</code></pre>

<h2 id="toc_5">导入vue工程中使用</h2>

<ul>
<li>main.js 入口文件</li>
</ul>

<blockquote>
<p>按照如下方式导入，工程就可以使用vuex的环境了</p>
</blockquote>

<pre><code class="language-JavaScript">// 导入vuex头文件
import Vuex from &#39;vuex&#39;
// 这里表示全局导入vuex
Vue.use(Vuex)
// 这里是我自定义的store文件 导出store对象
import store from &#39;@/study/vuexStudy/store/store.js&#39;
</code></pre>

<blockquote>
<p>入口组件<App/>中，绑定store</p>
</blockquote>

<pre><code>new Vue({
  el: &#39;#app&#39;,
  template: &#39;&lt;App/&gt;&#39;,
  components: { App },
  store
})
</code></pre>

<p>到这里 算是万里长征走了第一步。</p>

<h3 id="toc_6">创建Store对象</h3>

<h4 id="toc_7">store 的结构:</h4>

<pre><code class="language-JavaScript">export const store = new Vuex.Store({

  // ------state:状态值存储,这里可以存储n个状态的值
  state: {count: &#39;1&#39;},
  
  // ------getter:store中定义的getters可以认为是store的计算属性
  // getters接收state作为其第一个参数
  getters: {
    done (state) {
      return state.count + 5
    }
  },
  
  // ------mutations:状态值的改变，操作状态值
  // $store.commit(mutationsName, params)是更改状态值的唯一方法
  mutations: {
    increment (state) {
      // 变更状态
      state.count++
    }
  },

  // ------actions:可以认为是包装了mutations的function 需要用 dispatch(actionName) 的方式去派发
  actions: {
    add (context) {
      context.commit(&#39;increment&#39;)
    },
    addAsync (context) {
      // 延时1秒
      setTimeout(() =&gt; {
        context.commit(&#39;increment&#39;)
      }, 1000)
    }
  },
  // store可以合并几个子store，以此来进行项目的模块化
  modules: {
    a: moduleA,
    b: moduleB
  }
})
</code></pre>

<h4 id="toc_8">编辑定义store实体对象：</h4>

<ul>
<li>store.js文件中</li>
</ul>

<blockquote>
<p>这里为了便于抽离 我们外部声明城对象实体后嵌入绑定到store</p>
</blockquote>

<ol>
<li><p>创建一个store对象</p>

<pre><code class="language-JavaScript">export default const store = new Vuex.Store({
  state,//绑定之前创建的state对象到store中
  mutations,
  getters,
  actions,
  modules
})
</code></pre></li>
<li><p>定义一个状态对象 <code>state</code>（实体）</p>

<pre><code class="language-JavaScript">const state = {
  count: 0,
  state1: 1,
  state2: 2,
  state3: 3
}
</code></pre></li>
<li><p>定义getters对象</p>

<pre><code>const getters = {
  done (state) {
    return state.count + 5
  },
  getState1: function (state) {
    return state.state3
  },
  // ES6简写
  getState2: state =&gt;  state.state2
}
</code></pre></li>
<li><p>.vue 文件中直接获取state值</p>

<p>首先导入辅助函数：</p>

<pre><code>import { 
    mapState, 
    mapGetters, 
    mapMutations, 
    mapActions 
    } from &#39;vuex&#39;
</code></pre>

<ul>
<li>第一种方式：绑定到组件属性中，直接获取 （一般不用这个，绑定到computed中是最合适的）<code>$store.state.count</code>并使用</li>
</ul>

<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    }
}
</code></pre>

<ul>
<li>第二种方式： 绑定到计算属性中（适合对store中的原始状态值进行一定处理的情况）</li>
</ul>

<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    },
    computed:{
        testComputedCount1: function () {
            return this.$store.state.count + 22
        }
    }
}
</code></pre>

<ul>
<li>第三种方式：mapState辅助函数绑定状态state值到组件计算属性中</li>
</ul>

<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    },
    computed:{
        testComputedCount1: function () {
            return this.$store.state.count + 22
        },
        ...mapState({
            count: state =&gt; state.count,
            mapState1: state =&gt; state.state1,
            mapState2: state =&gt; state.state2
        }),
    }
}
</code></pre>

<ul>
<li>第四种方式：使用store中绑定的getters进行获取</li>
</ul>

<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    },
    computed:{
        testComputedCount1: function () {
            return this.$store.state.count + 22
        },
        ...mapState({
            count: state =&gt; state.count,
            mapState1: state =&gt; state.state1,
            mapState2: state =&gt; state.state2
        }),
        testComputedGettersCount2: funtion () {
            return this.$store.getters.done
        }
    }
}
</code></pre>

<ul>
<li>第五种方式： 借助mapGetters辅助函数绑定getters到vue的计算属性中</li>
</ul>

<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    },
    computed:{
        testComputedCount1: function () {
            return this.$store.state.count + 22
        },
        ...mapState({
            count: state =&gt; state.count,
            mapState1: state =&gt; state.state1,
            mapState2: state =&gt; state.state2
        }),
        testComputedGettersCount2: funtion () {
            return this.$store.getters.done
        },

        //直接绑定方法数组的方式
        ...mapGetters([
            &#39;getState1&#39;,
            &#39;getState2&#39;,
            &#39;getState3&#39;
        ]),

        //重命名对象绑定方式
        ...mapGetters({
          mapGetterState1: &#39;getState1&#39;,
          mapGetterState3: &#39;getState3&#39;
        }),
    }
}
</code></pre></li>
<li><p>触发动作行为改变状态值</p>

<blockquote>
<p>方式一：$store.commit(&#39;mutationsName&#39;)</p>

<p>方式二：$store.dispatch(&#39;actionsName&#39;)    </p>
</blockquote>

<p>store.js文件中：</p>

<ul>
<li>初始化 mutations 和 actions (相当于是methods)</li>
</ul>

<pre><code>const mutations = {
    increment (state) {
        // 变更状态
        state.count = state.count * 5
    }
}
</code></pre>

<pre><code>import {action4} from &#39;@/path/actions.js&#39;
const actions = {
    // 同步方法
    add: function (context) {
        context.commit(&#39;increment&#39;)
    },
    // 延时操作 用于网络请求啊啥的
    addAsync (context) {
        // 延时1秒
        setTimeout(() =&gt; {
            context.commit(&#39;increment&#39;)
        }, 1000)
    },
    // 简写方式
    action2 (context) {
        context.commit(&#39;increment&#39;)
    },
    // 抽离到单独文件中，在导进封装好的变量来直接使用即可（导进来的目的是为了接收第一个参数：state），不绑定到store，需要手动传入store对象
    action4: action4,
}
</code></pre></li>
</ol>

<ul>
<li><p>绑定action 和 mutations 到 methods，然后 调用就行了</p>

<pre><code>export default {
    methods: {
        // 数组形式直接载入
        ...mapActions([
            &#39;add&#39;
        ]),
        // 重命名形式 
        ...mapActions({
            add: &#39;add&#39;,
            addAsync: &#39;addAsync&#39;,
            action4: &#39;action4&#39;
        }),
        // 同上
        ...mapMutations([
            &#39;increment&#39;
        ]),
        ...mapMutations({
            incrementMutation: &#39;increment&#39;
        })
    }
}
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[react-native-splash-screen 给安卓项目添加启动图]]></title>
    <link href="http://blog.csdn.net/15151216159291.html"/>
    <updated>2018-01-05T11:06:55+08:00</updated>
    <id>http://blog.csdn.net/15151216159291.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">react-native-splash-screen 基本配置</h2>

<ul>
<li>安装插件：<code>npm install react-native-splash-screen --save</code></li>
<li>关联项目：<code>react-native link react-native-splash-screen</code> or <code>rnpm link react-native-splash-screen</code></li>
</ul>

<blockquote>
<p>link 之后，安卓项目中会自动添加头文件 以及部分代码，为保证项目顺利运行，还请确认下面代码是否已经完善。</p>
</blockquote>

<ul>
<li><p>确保 <code>android/settings.gradle</code>文件夹已经有下面代码</p>

<pre><code class="language-JavaScript">include &#39;:react-native-splash-screen&#39;   
project(&#39;:react-native-splash-screen&#39;).projectDir = new File(rootProject.projectDir, &#39;../node_modules/react-native-splash-screen/android&#39;)
</code></pre></li>
<li><p>android/app/build.gradle 文件中 添加依赖 <code>react-native-splash-screen</code></p>

<pre><code>...
dependencies {
...
compile project(&#39;:react-native-splash-screen&#39;)
}
</code></pre></li>
<li><p>更新 <code>MainApplication.java</code> 文件</p></li>
</ul>

<pre><code>// react-native-splash-screen &gt;= 0.3.1
import org.devio.rn.splashscreen.SplashScreenReactPackage;
// react-native-splash-screen &lt; 0.3.1
import com.cboy.rn.splashscreen.SplashScreenReactPackage;

public class MainApplication extends Application implements ReactApplication {

    private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {
        @Override
        protected boolean getUseDeveloperSupport() {
            return BuildConfig.DEBUG;
        }

        @Override
        protected List&lt;ReactPackage&gt; getPackages() {
            return Arrays.&lt;ReactPackage&gt;asList(
                    new MainReactPackage(),
            new SplashScreenReactPackage()  //here
            );
        }
    };

    @Override
    public ReactNativeHost getReactNativeHost() {
        return mReactNativeHost;
    }
}
</code></pre>

<h2 id="toc_1">准备添加代码和文件配置</h2>

<ul>
<li><code>app/src/main/res/layout</code> 文件夹下 添加 <code>launch_screen.xml</code> 并copy如下代码：</li>
</ul>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;@drawable/launch_screen&quot;&gt;
&lt;/LinearLayout&gt;
</code></pre>

<ul>
<li>创建文件夹 <code>drawable-xhdpi</code>、 <code>drawable-xxhdpi</code>（暂时先创建这两个就够了），将准备好的启动图 命名为 <code>launch_screen.png</code> 分别放入创建好的文件夹</li>
<li><p>白屏问题，设置透明背景：<code>android/app/src/main/res/values/styles.xml</code> 文件夹下 添加 <code>&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</code></p>

<pre><code>&lt;resources&gt;
&lt;!-- Base application theme. --&gt;
&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
    &lt;!-- Customize your theme here. --&gt;
    &lt;!--设置透明背景--&gt;
    &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;
&lt;/style&gt;
&lt;/resources&gt;
</code></pre></li>
<li><p><code>android/app/src/main/res/values/colors.xml</code> 文件夹下，添加如下：</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;color name=&quot;primary_dark&quot;&gt;#660B0B0B&lt;/color&gt; &lt;/resources&gt;
</code></pre></li>
<li><p>适当的时刻 隐藏启动图  可以是在视图挂载完毕，可以是网络请求结束之后</p></li>
</ul>

<pre><code>import SplashScreen from &#39;react-native-splash-screen&#39;
componentDidMount() {
    SplashScreen.hide();
  }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[佛祖镇楼 bug辟易]]></title>
    <link href="http://blog.csdn.net/15145327105445.html"/>
    <updated>2017-12-29T15:31:50+08:00</updated>
    <id>http://blog.csdn.net/15145327105445.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-Objective-C">//                            _ooOoo_
//                           o8888888o
//                           88&quot; . &quot;88
//                           (| -_- |)
//                            O\ = /O
//                        ____/`---&#39;\____
//                      .   &#39; \\| |// `.
//                       / \\||| : |||// \
//                     / _||||| -:- |||||- \
//                       | | \\\ - /// | |
//                     | \_| &#39;&#39;\---/&#39;&#39; | |
//                      \ .-\__ `-` ___/-. /
//                   ___`. .&#39; /--.--\ `. . __
//                .&quot;&quot; &#39;&lt; `.___\_&lt;|&gt;_/___.&#39; &gt;&#39;&quot;&quot;.
//               | | : `- \`.;`\ _ /`;.`/ - ` : | |
//                 \ \ `-. \_ __\ /__ _/ .-` / /
//         ======`-.____`-.___\_____/___.-`____.-&#39;======
//                            `=---=&#39;
//
//         .............................................
//                  佛祖镇楼                  BUG辟易
//          佛曰:
//                  写字楼里写字间，写字间里程序员；
//                  程序人员写程序，又拿程序换酒钱。
//                  酒醒只在网上坐，酒醉还来网下眠；
//                  酒醉酒醒日复日，网上网下年复年。
//                  但愿老死电脑间，不愿鞠躬老板前；
//                  奔驰宝马贵者趣，公交自行程序员。
//                  别人笑我忒疯癫，我笑自己命太贱；
//                  不见满街漂亮妹，哪个归得程序员？
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习资源网址]]></title>
    <link href="http://blog.csdn.net/15139059079620.html"/>
    <updated>2017-12-22T09:25:07+08:00</updated>
    <id>http://blog.csdn.net/15139059079620.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">技术学习资源</h2>

<h3 id="toc_1">sublime学习资源</h3>

<ul>
<li><a href="http://www.jianshu.com/p/aa30cc25c91b">Sublime 入门+进阶</a>：<code>http://www.jianshu.com/p/aa30cc25c91b</code></li>
<li><a href="http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/">sublime全解</a>: <code>http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/</code></li>
<li><a href="https://dribbble.com/">Sublime 图标下载</a>: <code>https://dribbble.com/</code></li>
</ul>

<h3 id="toc_2">MarkDown学习资源</h3>

<span id="more"></span><!-- more -->

<ul>
<li><a href="http://wowubuntu.com/markdown/">Wow!Ubuntu</a>: <code>http://wowubuntu.com/markdown/</code></li>
<li><a href="http://blog.csdn.net/witnessai1/article/details/52551362">Markdown 语法手册</a>: <code>http://blog.csdn.net/witnessai1/article/details/52551362</code></li>
<li><a href="https://sanwen8.cn/p/670KuHA.html"> 精致Markdown【语法篇】</a>:<code>https://sanwen8.cn/p/670KuHA.html</code></li>
<li><a href="https://segmentfault.com/markdown">Markdown编辑器语法指南 - SegmentFault</a> : <code>https://segmentfault.com/markdown</code><br/></li>
<li><a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/">sublime + Markdown</a>: <code>http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/</code></li>
</ul>

<h3 id="toc_3">Shell脚本学习资源</h3>

<ul>
<li><a href="http://www.runoob.com/linux/linux-shell.html">shell教程</a>: <code>http://www.runoob.com/linux/linux-shell.html</code></li>
<li><a href="http://www.cnblogs.com/Lynn-Zhang/p/5758287.html">shell脚本入门</a>: <code>http://www.cnblogs.com/Lynn-Zhang/p/5758287.html</code></li>
</ul>

<h3 id="toc_4">Git命令学习资源</h3>

<ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">Git命令清单--阮一峰</a>: <code>http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</code></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程--廖雪峰</a>: <code>http://www.liaoxuefeng.com</code></li>
<li><a href="https://segmentfault.com/a/1190000009491296">本地项目推送到远程git仓库</a>: <code>https://segmentfault.com/a/1190000009491296</code></li>
<li><a href="https://segmentfault.com/a/1190000009516449">Git使用教程--segmenfault</a>: <code>https://segmentfault.com/a/1190000009516449</code></li>
</ul>

<h3 id="toc_5">Mac终端命令</h3>

<ul>
<li><a href="http://www.jianshu.com/p/3291de46f3ff">终端命令大全:简书</a>：<code>http://www.jianshu.com/p/3291de46f3ff</code></li>
<li><a href="http://blog.csdn.net/u014220518/article/details/53282785">Mac终端命令总结</a>： <code>http://blog.csdn.net/u014220518/article/details/53282785</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rect-Native 之 Promise 深入浅出从入门到精通]]></title>
    <link href="http://blog.csdn.net/15139057022845.html"/>
    <updated>2017-12-22T09:21:42+08:00</updated>
    <id>http://blog.csdn.net/15139057022845.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">概念理解</h2>

<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fhp9dw6vxpj307406ewek.jpg" alt="icon" title="React icon"/></p>

<blockquote>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h3 id="toc_1">Promise 状态</h3>

<ul>
<li>Pending 进行中</li>
<li>Resolved 已完成 又称Fulfilled</li>
<li>Rejected 已失败</li>
</ul>

<h3 id="toc_2">Promise 特点</h3>

<ul>
<li>对象的状态不受外部因素影响。Promise对象代表的是一个异步操作，只有异步操作的结果能决定Promise的状态，任何其他操作都不能决定其状态。</li>
<li>一旦Promise有了结果状态就不会再变。<code>Pending==&gt;Resolved</code>,或者<code>Pending==&gt;Rejected</code></li>
</ul>

<h3 id="toc_3">Promise 缺点</h3>

<p>Promise的缺点是：一旦建立就会立即执行，无法中途取消。</p>

<h2 id="toc_4">Promise 基本用法</h2>

<pre><code class="language-JavaScript">var promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
</code></pre>

<p>Promise对象接受一个参数，这个参数是一个函数体。<br/>
这个函数有两个参数：一个是resolve，一个是reject。这两个参数是Promise自动提供，不需要使用者传值。<br/>
* resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 Pending 变为 Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去<br/>
* reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 Pending 变为 Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。<br/>
  Promise实例生成后，可以用then分别指定Resolved和Rejected的回调函数。<br/>
<code>JavaScript<br/>
promise.then(function(value) {<br/>
  // success<br/>
}, function(error) {<br/>
  // failure<br/>
});<br/>
</code><br/>
then方法会接受两个参数：<br/>
* 第一个函数，Promise状态变更为Resolved时调用。<br/>
* 第二个函数，Promise状态变为Rejected时调用。可选的，可以不提供。</p>

<p>下面是异步加载图片的例子：<br/>
```JavaScript<br/>
function loadImageAsync(url) {<br/>
  return new Promise(function(resolve, reject) {<br/>
    var image = new Image();</p>

<pre><code>image.onload = function() {
  resolve(image);
};

image.onerror = function() {
  reject(new Error(&#39;Could not load image at &#39; + url));
};

image.src = url;
</code></pre>

<p>});<br/>
}<br/>
<code><br/>
下面是Promise实现的Ajax操作的例子：<br/>
</code>JavaScript<br/>
var getJSON = function(url) {<br/>
  var promise = new Promise(function(resolve, reject){<br/>
    var client = new XMLHttpRequest();<br/>
    client.open(&quot;GET&quot;, url);<br/>
    client.onreadystatechange = handler;<br/>
    client.responseType = &quot;json&quot;;<br/>
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);<br/>
    client.send();<br/>
    function handler() {<br/>
      if (this.readyState !== 4) {<br/>
        return;<br/>
      }<br/>
      if (this.status === 200) {<br/>
        resolve(this.response);<br/>
      } else {<br/>
        reject(new Error(this.statusText));<br/>
      }<br/>
    };<br/>
  });</p>

<p>return promise;<br/>
};</p>

<p>getJSON(&quot;/posts.json&quot;).then(function(json) {<br/>
  console.log(&#39;Contents: &#39; + json);<br/>
}, function(error) {<br/>
  console.error(&#39;出错了&#39;, error);<br/>
});<br/>
```<br/>
<strong>注意：在getJSON内部，resolve函数和reject函数调用时，都带有参数！！</strong><br/><br/>
    如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。<br/>
* reject函数的参数通常是Error对象的实例，表示抛出的错误<br/>
* resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作</p>

<pre><code class="language-JavaScript">var p1 = new Promise(function (resolve, reject) {
  // ...
});

var p2 = new Promise(function (resolve, reject) {
  // ...
  resolve(p1);
})
</code></pre>

<p>上面👆，<code>p1</code>、<code>p2</code> 都是Promise，但是<code>p2</code>的resolve把<code>p1</code>作为返回值参数传出去了，即一个异步操作的返回结果是另一个异步操作。（类似于iOS开发中的自动布局库 <code>Masonry</code>,可以无限点语法取到对象）。<br/><br/>
<strong>注意：此时，p1的状态会传递p2.如果p1是Pending状态,那么p2会等待p1的结果。如果p1是Reject或者Resolve状态，那么p2的回调函数将会立即执行。</strong></p>

<p><strong>再看:</strong><br/>
```JavaScript<br/>
var p1 = new Promise(function (resolve, reject) {<br/>
  setTimeout(() =&gt; reject(new Error(&#39;fail&#39;)), 3000)<br/>
})</p>

<p>var p2 = new Promise(function (resolve, reject) {<br/>
  setTimeout(() =&gt; resolve(p1), 1000)<br/>
})</p>

<p>p2.then(result =&gt; console.log(result))<br/>
  .catch(error =&gt; console.log(error))<br/>
// Error: fail<br/>
```</p>

<ol>
<li><code>p1</code>会在3秒后抛出error。<br/></li>
<li><code>p2</code>会在1秒后改变状态。Resolv的返回值是<code>p1</code>.<br/></li>
<li>由于<code>p2</code>的返回值是一个Promise，导致<code>p2</code>自己的状态无效了，此时<code>p2</code>的状态取决于<code>p1</code>.<br/></li>
<li>所以，后面的then语句，都变成针对p1的了。<br/></li>
<li>又过了<code>2秒</code>，<code>p1</code>变为<code>reject</code>，导致触发<code>catch</code>方法。<br/></li>
</ol>

<h2 id="toc_5">3. Promise.prototype.then()</h2>

<p><strong>then方法是定义在原型对象Promise.prototype上的。</strong><br/>
作用：为Promise对象添加状态改变时的回调函数。第一个是Resolved，第二个是Rejected。<br/>
then方法返回的是一个新的Promise对象，不是之前的实例。因此 then方法后面还可以再写一个then方法,即链式调用。</p>

<pre><code class="language-JavaScript">getJSON(&quot;/posts.json&quot;).then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
</code></pre>

<p>第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>

<pre><code class="language-JavaScript">getJSON(&quot;/post/1.json&quot;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function funcA(comments) {
  console.log(&quot;Resolved: &quot;, comments);
}, function funcB(err){
  console.log(&quot;Rejected: &quot;, err);
});
</code></pre>

<p>第一个then函数返回的是一个新的Promise对象。于是才能继续调用then方法。<br/>
第二个then方法指定的回调函数，就会等待这个Promise对象状态发生变化，resolv会调用funcA,reject会调用funcB.</p>

<p>下面👇是箭头函数的实现，会更简洁：<br/>
<code>JavaScript<br/>
getJSON(&quot;/post/1.json&quot;).then(<br/>
  post =&gt; getJSON(post.commentURL)<br/>
).then(<br/>
  comments =&gt; console.log(&quot;Resolved: &quot;, comments),<br/>
  err =&gt; console.log(&quot;Rejected: &quot;, err)<br/>
);<br/>
</code></p>

<h2 id="toc_6">4. Promise.prototype.catch()</h2>

<h3 id="toc_7">Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数</h3>

<p><strong>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数.</strong><br/><br/>
<code>JavaScript<br/>
getJSON(&#39;/posts.json&#39;).then(function(posts) {<br/>
  // ...<br/>
}).catch(function(error) {<br/>
  // 处理 getJSON 和 前一个回调函数运行时发生的错误<br/>
  console.log(&#39;发生错误！&#39;, error);<br/>
});<br/>
</code></p>

<p>getJSON()方法返回的是一个Promise对象。如果resolv，会调用then方法；如果reject则会调用catch方法。</p>

<h3 id="toc_8">then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获</h3>

<p><strong>另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获</strong>   </p>

<pre><code class="language-JavaScript">p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))
  .catch((err) =&gt; console.log(&#39;rejected&#39;, err));

// 等同于
p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
</code></pre>

<pre><code>var promise = new Promise(function(resolve, reject) {
  throw new Error(&#39;test&#39;);
});
promise.catch(function(error) {
  console.log(error);
});
// Error: test
</code></pre>

<p>Promise对象Resolved，但是Resolved指定的方法跑出错误。<br/>
Promise对象catch方法能捕获跑出的error。</p>

<h3 id="toc_9">reject方法等同于抛出错误</h3>

<p>上面的写法跟下面的两种写法是一样的：<br/>
```<br/>
// 写法一<br/>
var promise = new Promise(function(resolve, reject) {<br/>
  try {<br/>
    throw new Error(&#39;test&#39;);<br/>
  } catch(e) {<br/>
    reject(e);<br/>
  }<br/>
});<br/>
promise.catch(function(error) {<br/>
  console.log(error);<br/>
});</p>

<p>// 写法二<br/>
var promise = new Promise(function(resolve, reject) {<br/>
  reject(new Error(&#39;test&#39;));<br/>
});<br/>
promise.catch(function(error) {<br/>
  console.log(error);<br/>
});<br/>
```</p>

<p><strong>由此可见：reject方法等同于抛出错误。</strong></p>

<h3 id="toc_10">resolve之后在抛出错误，catch是捕获不到的不到的。</h3>

<pre><code>var promise = new Promise(function(resolve, reject) {
  resolve(&#39;ok&#39;);
  throw new Error(&#39;test&#39;);
});
promise
  .then(function(value) { console.log(value) })
  .catch(function(error) { console.log(error) });
// ok
</code></pre>

<p><strong>resolve之后在抛出错误，catch是捕获不到的不到的。</strong></p>

<h3 id="toc_11">Promise 对象的错误具有“冒泡”性质</h3>

<p><strong>Promise 对象的错误具有“冒泡”性质,会一直向后传递，直到被捕获为止 ------ 错误总是会被下一个catch语句捕获</strong></p>

<blockquote>
<p>举个栗子：就像是Y染色体上受环境触发的遗传疾病，会不断的遗传给男性后代，任意一个男性都会被特殊的环境触发。</p>
</blockquote>

<pre><code>getJSON(&#39;/post/1.json&#39;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
</code></pre>

<p>上述代码中有三个Promise，第一个由getJSON产生，后两个由then产生。他们之中的任何一个抛出错误，都会被catch捕获。</p>

<p>一般来讲，尽量不要定义Promise的reject状态的回调函数，最好总是使用catch函数，因为catch函数不仅能捕获到reject状态，还能捕获到resolve状态指定方法下抛出的异常。</p>

<h3 id="toc_12">Promise对象抛出的错误不会传递到外层代码</h3>

<p>如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应，这一点上跟传统的try/catch代码块不同的。</p>

<pre><code>process.on(&#39;unhandledRejection&#39;, function (err, p) {
  console.error(err.stack)
});
</code></pre>

<p>时间的监听函数‘unhandledRejection’,有两个参数：<br/>
第一个是错误对象<br/>
第二个是报错的Promise实例</p>

<p>catch方法返回的也是一个Promise实例，所以后面还是可以无限的调用then方法。<br/>
如果catch函数在几个then中间，二执行过程中都没有reject状态，那么会跳过这个中间的catch方法。</p>

<h3 id="toc_13">catch方法中也能抛出错误</h3>

<pre><code>var someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};

someAsyncThing().then(function() {
  return someOtherAsyncThing();
}).catch(function(error) {
  console.log(&#39;oh no&#39;, error);
  // 下面一行会报错，因为y没有声明
  y + 2;
}).then(function() {
  console.log(&#39;carry on&#39;);
});
// oh no [ReferenceError: x is not defined]
</code></pre>

<p>如上：catch方法指定的函数依旧是可以抛出Error的，但是因为后面没有继续跟进catch方法，所以并没有被捕获。</p>

<h2 id="toc_14">5. Promise.all()</h2>

<p><strong>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</strong></p>

<pre><code>var p = Promise.all([p1, p2, p3]);
</code></pre>

<p>Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。<br/>
（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>

<p>p的状态由p1、p2、p3决定，分成两种情况:<br/>
* 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数<br/>
* 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数</p>

<p><strong>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</strong></p>

<pre><code>const p1 = new Promise((resolve, reject) =&gt; {
  resolve(&#39;hello&#39;);
})
.then(result =&gt; result)
.catch(e =&gt; e);

const p2 = new Promise((resolve, reject) =&gt; {
  throw new Error(&#39;报错了&#39;);
})
.then(result =&gt; result)
.catch(e =&gt; e);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
</code></pre>

<p>p1会resolved，p2首先会rejected.<br/>
p2有自己的catch方法，并且执行了，那么就会返回一个新的Promise，并且这个Promise的状态会变成Resolved。<br/>
所以：Promise.all()的catch方法并不能捕获到这个error。<br/>
p2没有自己的catch方法，所以会调用Promise.all()的catch方法。</p>

<h2 id="toc_15">6. Promise.race()</h2>

<p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。<br/>
<code><br/>
var p = Promise.race([p1, p2, p3]);<br/>
</code><br/>
p1/p2/p3中只要有一个率先改变状态，p的状态就会随着改变。那个率先改变状态的实例的返回值，就会传递给p的回调函数。<br/>
<code><br/>
const p = Promise.race([<br/>
  fetch(&#39;/resource-that-may-take-a-while&#39;),<br/>
  new Promise(function (resolve, reject) {<br/>
    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)<br/>
  })<br/>
]);<br/>
p.then(response =&gt; console.log(response));<br/>
p.catch(error =&gt; console.log(error));<br/>
</code></p>

<p>5秒内无法返回请求结果，变量p的状态就会变为reject。这也算是竞速的一种应用场景。</p>

<h2 id="toc_16">7. Promise.resolve()</h2>

<p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用.</p>

<pre><code>var jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));
</code></pre>

<p>等价于下面的说法：<br/>
<code><br/>
Promise.resolve(&#39;foo&#39;)<br/>
// 等价于<br/>
new Promise(resolve =&gt; resolve(&#39;foo&#39;))<br/>
</code></p>

<p>Promise 的第一个参数是一个箭头函数，函数的传入参数是resolve（函数），函数体就是调用传入的函数resolve，resolve调用的时候，也需要一个参数，此时这个参数就是咱们需要转变成Promise对象的那个参数。</p>

<p>Promise.resolve的参数有四种情况：<br/>
1. 参数是一个Promise实例<br/>
2. 参数是一个thenable对象（有then方法的实例）<br/>
3. 参数是不具备then方法d的对象应该<br/>
4. 不带参数，返回一个Resolved的返回状态。</p>

<h2 id="toc_17">8、Promise.reject()   同上</h2>

<h2 id="toc_18">9、两个常用附加方法</h2>

<h3 id="toc_19">done()</h3>

<p>Promise的错误并不会冒泡到全局，所以我们可以提供一个done方法总是处于会吊链的尾端。<br/>
<code><br/>
asyncFunc()<br/>
  .then(f1)<br/>
  .catch(r1)<br/>
  .then(f2)<br/>
  .done();<br/>
</code></p>

<p>done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出.</p>

<h3 id="toc_20">finally()</h3>

<p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>

<pre><code>Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  =&gt; P.resolve(callback()).then(() =&gt; value),
    reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })
  );
};
</code></pre>

<h3 id="toc_21">Promis.try()</h3>

<pre><code>try {
  database.users.get({id: userId})
  .then(...)
  .catch(...)
} catch (e) {
  // ...
}
</code></pre>

<pre><code>Promise.try(database.users.get({id: userId}))
  .then(...)
  .catch(...)
</code></pre>

<p>Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 笔记（Array）]]></title>
    <link href="http://blog.csdn.net/15137645005542.html"/>
    <updated>2017-12-20T18:08:20+08:00</updated>
    <id>http://blog.csdn.net/15137645005542.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">array</h2>

<ol>
<li><p>Array.from<br/>
将类似数组的对象（array-like object）和可遍历（iterable）的对象 转换为数组。</p>

<ul>
<li>类数组：有 length属性的对象</li>
<li>可遍历：包含Set Map.</li>
</ul></li>
<li><p>Array.of<br/>
该方法用于将一组值，转换为数组。</p></li>
</ol>

<span id="more"></span><!-- more -->

<ol>
<li><p>copyWithin<br/>
在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员）。</p>

<ul>
<li>      target（必需）：从该位置开始替换数据。</li>
<li>      start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>      end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul></li>
<li><p>数组实例的find()和findIndex()<br/>
用于找出第一个符合条件的数组成员。<br/>
用于找出第一个符合条件的数组成员的位置。</p></li>
<li><p>fill<br/>
方法使用给定值，填充一个数组。<br/>
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)<br/>
// [&#39;a&#39;, 7, &#39;c&#39;];// 左闭右开</p></li>
<li><p>数组实例的entries()，keys()和values()<br/>
keys()是对键名的遍历<br/>
values()是对键值的遍历<br/>
entries()是对键值对的遍历</p></li>
<li><p>Array.prototype.includes方法<br/>
返回一个布尔值，表示某个数组是否包含给定的值。<br/>
[1, 2, 3].includes(3, -1); // true<br/>
3:将要搜索的item<br/>
-1：搜索的起始位置  </p></li>
<li><p>数组的空位<br/>
数组的空位指，数组的某一个位置没有任何值。</p></li>
</ol>

<p>空位不是undefined，undefined是有值的。<br/>
空位是没有任何值。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 笔记（常量&&变量）]]></title>
    <link href="http://blog.csdn.net/15137627946753.html"/>
    <updated>2017-12-20T17:39:54+08:00</updated>
    <id>http://blog.csdn.net/15137627946753.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">变量&amp;&amp;常量</h2>

<h3 id="toc_1">新特性</h3>

<ol>
<li><p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p></li>
<li><p>变量提升：var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined；为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p></li>
<li><p>暂时性死区：在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”；</p></li>
</ol>

<span id="more"></span><!-- more -->

<pre><code>```
var tmp = 123;

if (true) {
tmp = &#39;abc&#39;; // ReferenceError  死区
let tmp;
}
```

&gt; let不允许在相同作用域内，重复声明同一个变量。
</code></pre>

<h3 id="toc_2">块级作用域</h3>

<ul>
<li>内层作用域可以定义外层作用域的同名变量。</li>
<li>内部作用域  重名变量  不会影响，</li>
<li>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数（ES5不允许）。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>函数声明还会提升到所在的块级作用域的头部。</li>
</ul>

<blockquote>
<p>块级作用域是一个语句，将多个操作封装在一起，没有返回值。<br/>
在块级作用域之前加上do，使它变为do表达式。会得到整个块级作用域的返回值</p>
</blockquote>

<h3 id="toc_3">const:</h3>

<ul>
<li>const声明一个只读的常量。一旦声明，常量的值就不能改变。</li>
<li>const一旦声明变量，就必须立即初始化，不能留到以后赋值。</li>
<li>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</li>
<li><p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p></li>
<li><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动</p></li>
<li><p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p></li>
<li><p>如果真的想将对象冻结，应该使用Object.freeze方法</p></li>
</ul>

<pre><code class="language-JavaScript">//冻结对象属性：
var constantize = (obj) =&gt; {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) =&gt; {
    if ( typeof obj[key] === &#39;object&#39; ) {
      constantize( obj[key] );
    }
  });
};
</code></pre>

<h3 id="toc_4">变量声明：</h3>

<blockquote>
<p>ES5 只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法</p>
</blockquote>

<ul>
<li>顶层对象的属性：
ES5中 顶层对象的属性  和 全局变量是一回事儿；全局变量是静态创建，而对象属性是动态创建的；不合理。
ES6中 var function 声明的全局变量 依然是顶层对象的属性；但是 let const class声明的全局变量 不属于顶层对象的属性。</li>
</ul>

<!-- more -->

<ul>
<li>全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。</li>
<li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</li>
<li>不管是严格模式，还是普通模式，new Function(&#39;return this&#39;)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。</li>
</ul>

<pre><code class="language-JavaScript">// 方法一
(typeof window !== &#39;undefined&#39;
   ? window
   : (typeof process === &#39;object&#39; &amp;&amp;
      typeof require === &#39;function&#39; &amp;&amp;
      typeof global === &#39;object&#39;)
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== &#39;undefined&#39;) { return self; }
  if (typeof window !== &#39;undefined&#39;) { return window; }
  if (typeof global !== &#39;undefined&#39;) { return global; }
  throw new Error(&#39;unable to locate global object&#39;);
};
</code></pre>

<p>// ES6模块的写法<br/>
import getGlobal from &#39;system.global&#39;;<br/>
const global = getGlobal();</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6笔记（解构赋值）]]></title>
    <link href="http://blog.csdn.net/15137621729153.html"/>
    <updated>2017-12-20T17:29:32+08:00</updated>
    <id>http://blog.csdn.net/15137621729153.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">解构赋值</h2>

<h3 id="toc_1">变量的解构：</h3>

<ul>
<li>解构赋值允许指定默认值。</li>
<li>解构赋值必须保证赋值方  被赋值方类型一直  但Item允许有遗漏或者多出。</li>
<li>默认值可以引用解构赋值的其他变量，但该变量必须已经声明</li>
</ul>

<pre><code>let [x = 1, y = x] = [];     // x=1; y=1
let [x = y, y = 1] = [];     // ReferenceError
</code></pre>

<span id="more"></span><!-- more -->

<h3 id="toc_2">对象的 解构赋值：</h3>

<ul>
<li>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；</li>
<li><p>而对象的属性没有次序，变量必须与属性同名，才能取到正确的值<br/>
（数据库、序列化）</p></li>
<li><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者；前者是key,后者才是变量！</p>

<blockquote>
<p>注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。</p>
</blockquote></li>
</ul>

<h3 id="toc_3">字符串的解构赋值</h3>

<blockquote>
<p>字符串也可以解构赋值。<br/>
这是因为此时，字符串被转换成了一个类似数组的对象<br/>
类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
</blockquote>

<pre><code class="language-JavaScript">let {length : len} = &#39;hello&#39;;
len // 5

let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true

let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
</code></pre>

<p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。<br/>
undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>

<ul>
<li>不能使用圆括号的情况

<ul>
<li>变量声明语句中，不能带有圆括号</li>
<li>函数参数中，模式不能带有圆括号。</li>
<li>赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中</li>
</ul></li>
<li>可以使用圆括号的情况只有一种：赋值语句的<strong>非模式部分</strong>，可以使用圆括号。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS打包上架素材准备概要说明]]></title>
    <link href="http://blog.csdn.net/15130872092436.html"/>
    <updated>2017-12-12T22:00:09+08:00</updated>
    <id>http://blog.csdn.net/15130872092436.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">开发者打包</h2>

<h3 id="toc_1">Xcode配置</h3>

<p><em>Xcode8 旧标准</em></p>

<ul>
<li><p>Xcode8 icon iPhone</p>

<ul>
<li><code>icon-29.png        29*29</code></li>
<li><code>icon-29@2x.png     58*58</code></li>
<li><code>icon-29@3x.png     87*87</code></li>
<li><code>icon-40@2x.png     80*80</code></li>
<li><code>icon-40@3x.png     120*120</code></li>
<li><code>icon-57.png        57*57</code></li>
<li><code>icon-57@2x.png     114*114</code></li>
<li><code>iocn-60@2x.png     120*120</code></li>
<li><code>icon-60@3x.png     180*180</code></li>
<li><code>icon-20@2x.png     40*40</code></li>
<li><code>icon-20@3x.png     60*60</code><br/></li>
</ul></li>
<li><p>Xcode8 LaunchImage：</p>

<ul>
<li><code>414*736 @3x    1242*2208</code></li>
<li><code>736*414  @3x    2208*1242</code></li>
<li><code>375*667 @2x    750*1334</code></li>
<li><code>320*568 @2x    640*1136</code></li>
<li><code>320*480 @2x    640*960</code></li>
<li><code>320*480 @1x    320*480</code></li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->

<p><em>Xcode9 新标准</em></p>

<blockquote>
<p><em>产品和美工同学组要注意下了</em><br/>
@2x 代表2倍图 <br/>
@3x代表三倍图<br/>
pt代表的是物理像素（或者自然像素）</p>
</blockquote>

<ul>
<li>Xcode9 icon :

<ul>
<li>iPhone 8张icon

<ul>
<li><code>20pt  @2x  @3x</code></li>
<li><code>29pt  @2x  @3x</code></li>
<li><code>40pt  @2x  @3x</code></li>
<li><code>60pt  @2x  @3x</code></li>
</ul></li>
<li>Xcode9 ipad

<ul>
<li><code>20pt  @1x  @2x</code></li>
<li><code>29pt  @1x  @2x</code></li>
<li><code>40pt  @1x  @2x</code></li>
<li><code>76pt  @1x  @2x</code></li>
<li><code>83.5pt @2x</code></li>
</ul></li>
<li>AppStore  <code>1024*1024 @1x</code></li>
<li>Xcode9 LaunchImage：

<ul>
<li><code>375*812 @3x    1125*2436</code></li>
<li><code>812*375 @3x    2436*1125</code></li>
<li><code>414*736 @3x    1242*2208</code></li>
<li><code>736*414  @3x    2208*1242</code></li>
<li><code>375*667 @2x    750*1334</code></li>
<li><code>320*568 @2x    640*1136</code></li>
<li><code>320*480 @2x    640*960</code></li>
<li><code>320*480 @1x    320*480</code></li>
</ul></li>
</ul></li>
</ul>

<p><em>Xcode 配置注意事项</em></p>

<ul>
<li>强制https：如果现版本APP还需要访问http请求那么需要配置info.plist文件</li>
<li>release模式：开发者都懂得。</li>
<li>证书配置：确保上架期间证书不要失效即可。</li>
<li>功能配置：比如推送、支付、蓝牙等</li>
<li>APPgroup配置 功能新的数据存储共享等需要注意，详情请自行百度。</li>
<li>Info.plist权限配置：后台声音、网络数据、推送、地理位置、摄像头权限、相册权限等</li>
</ul>

<h2 id="toc_2">AppStore 上架</h2>

<h3 id="toc_3">APP信息</h3>

<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fkvh47o1voj31330hx0uf.jpg" alt="APP信息截图"/></p>

<h4 id="toc_4">可本地化的信息</h4>

<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fkvksptazij30ky04q75q.jpg" alt="AppStore 中APP列表显示"/></p>

<h5 id="toc_5">名称</h5>

<p>App Title（名称）允许255个字节，大概90个字符，原则上充分利用所有字符；例如《趣味牛牛－史上最休闲的游戏，天天QQ微信博易空间飞车坑爹泡泡龙12306狗我多米虾音乐节奏大师，找你妹酷跑保卫萝卜陌陌游览器爱消除yyppstv，炸金花全民英雄NBA快播联盟魔漫相机斗地主风行唱吧》。随着苹果审核愈趋严格的大环境下，单纯的热词堆砌是行不通的，在热词填充APP Title时需要保证语句的通畅以及无矛盾存在（苹果审核人员的汉语理解能力这两年可用突飞猛进形容）</p>

<h5 id="toc_6">副标题</h5>

<p>App 摘要，显示在APP详情中。如果客户的设备运行 iOS 11 或更高版本，在 App Store 中，副标题会显示在您的 App 名称下方。<br/>
利用副标题的高权重，采用轮换战术，优化各个关核心键词，当已有核心关键词排名优化靠前，选用其他的核心关键词</p>

<h5 id="toc_7">隐私政策网站</h5>

<p>APP涉及隐私权限问题的保护策略声明等。对APP用户信息保密性要求高的比如支付等功能可能需要提供一个隐私声明网页。</p>

<h4 id="toc_8">综合信息</h4>

<h5 id="toc_9">套装ID</h5>

<p>就是APP开发过程中的跟证书保持一致的 boundleID,功能上用来唯一标识APP的字符串.</p>

<h5 id="toc_10">SKU</h5>

<p>一个系列APP的成为套装，如Word、Excel，这个名字有辨识度即可。</p>

<h5 id="toc_11">Apple ID</h5>

<p>APP上架后再APPStore的身份ID，APP创建的时候自动生成，并且不可改变。</p>

<h5 id="toc_12">主要语言</h5>

<p>APP所支持的国际化语言，比如简体中文，繁体中文，英文等。</p>

<h5 id="toc_13">许可协议</h5>

<p>详情请参考: <a href="https://www.apple.com/legal/internet-services/itunes/dev/stdeula/">Apple标准许可协议</a></p>

<h5 id="toc_14">分级</h5>

<p>根据APP内容 （色情、暴力、赌博、广告等）进行评判的标准来定等级，看适合哪个年龄段的使用者下载。包含AppStore所限制的内容越少，越容易上架。<br/>
<img src="https://ws2.sinaimg.cn/large/006tNc79ly1fkvl0vs70kj318k1cbaj8.jpg" alt="等级分级"/></p>

<h5 id="toc_15">类别</h5>

<p>主要类别：<br/>
<img src="https://ws3.sinaimg.cn/large/006tNc79ly1fkvl7yz1tfj30qc0pmgnu.jpg" alt="主要类别分类"/><br/>
次要类别：<br/>
<img src="https://ws4.sinaimg.cn/large/006tNc79ly1fkvl9mmsyrj30pk0pgwgo.jpg" alt="次要类别分类"/></p>

<h3 id="toc_16">价格与销售范围</h3>

<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fkvlbvk29mj312v0gsmyl.jpg" alt="价格与销售范围"/></p>

<h4 id="toc_17">价格时间表</h4>

<p>这里可以选择定价的时间范围。比如 某一个时间段内APP限时免费。就可以规定一个价格，一个起止时间段。</p>

<h4 id="toc_18">销售范围</h4>

<p>比如有些APP只能在国内使用，那就选择中国🇨🇳。</p>

<h4 id="toc_19">批量购买计划</h4>

<p>大型APP的购买的优惠策略，现在通过AppStore的策略比较少了。现在的大型APP大都是免费下载，然后限时体验，体验时间过后在向你收费，如果觉得确实不错，用户就可以选择购买。这样对用户来说更合理。</p>

<h4 id="toc_20">Bitcode 自动重新编译</h4>

<p>这个是针对开发者的，大多数的老项目都不支持bitcode,新项目大都是支持的。<br/>
<img src="https://ws4.sinaimg.cn/large/006tNc79ly1fkvlm6sjuaj30qy0b576f.jpg" alt="bitcode自动变异详情"/></p>

<h3 id="toc_21">APP版本信息</h3>

<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fkvlqr205zj31kw0ttgwn.jpg" alt="APP版本信息"/></p>

<h4 id="toc_22">版本信息</h4>

<h4 id="toc_23">APP预览和屏幕快照</h4>

<p>iOS10之前，不同尺寸的手机都需要上传一套APP截图，每一套3-5张。</p>

<p><code>320*480</code><br/>
<code>320*568</code><br/>
<code>375*667</code><br/>
<code>414*736</code></p>

<p>iOS10之后apple放弃了对320*480尺寸的支持，所剩下的机型长宽比都是一致的，所以可以共用一套APP截图的，当然如果不嫌麻烦想不同机型有不同的展示截图可以选择iOS10之前的模式，上传多套看截图。</p>

<p>iOS10之后需要 <code>414*736</code>  @3x 三倍图 即：<code>1242 * 2208</code> 的截图。</p>

<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fkvm57vwduj31ag0f50ul.jpg" alt="APP截图可以选择公用5.5寸高清版本"/></p>

<h4 id="toc_24">宣传文本</h4>

<p>宣传文本可通知 App Store 访客当前最新的 App 功能，您无需提交更新请求。如果客户的设备运行 iOS 11 或更高版本，在 App Store 中，宣传文本会显示在您的 App 名称下方。</p>

<h4 id="toc_25">描述</h4>

<p>对APP的详细描述，主要模式：<br/>
哪家公司的什么APP干什么用有什么优点。</p>

<ul>
<li>描述性的字数控制在300-500，并保证核心关键词8-12的频次出现。</li>
<li>最好出现公司的联系方式，如公众号/微博账号/服务QQ/QQ群等。</li>
<li>描述中出现的关键词主要是对Keywords的补充，Keywords的权重和描述的权重是可以叠加的。</li>
</ul>

<h4 id="toc_26">关键词</h4>

<p>一个或多个关键词，用以描述您的 App。关键词将使 App Store 搜索结果更加准确。关键词之间用英文逗点分隔。</p>

<h4 id="toc_27">技术支持网址</h4>

<h4 id="toc_28">营销网址</h4>

<h4 id="toc_29">构建版本</h4>

<h4 id="toc_30">APP综合信息</h4>

<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fkvh124ghrj31370h5acw.jpg" alt=""/></p>

<h5 id="toc_31">AppStore图表</h5>

<p>1024*1024 没有开启alpha通道的PNG格式图片。</p>

<h5 id="toc_32">版本</h5>

<p>当前上架APP的版本号</p>

<h5 id="toc_33">分级</h5>

<p>同上</p>

<h5 id="toc_34">版权</h5>

<p>公司申请开发账号的时候就应该知道的，不清楚的吻公司账号申请人。</p>

<h5 id="toc_35">商务代表联系信息</h5>

<p>这个填写公司的上午代表联系人。个人开发账号那就是填写自己信息了。</p>

<h5 id="toc_36">APP审核信息</h5>

<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fkvgu6xxxlj31jx0phq80.jpg" alt="APP审核信息截图"/></p>

<ul>
<li>登录信息：如果APP需要登录APP则需要提供相应的测试账号，以便测试人员登录测试。</li>
<li>备注：请提供用户名和密码，以便Apple测试人员登录 App。apple测试人员需要使用此登录信息才能完成对您App 的审核。  或者APP的操作需要什么特殊的操作指引，也需要在这里进行备注。注：即使登录信息位置填写了账号密码，备注内仍建议再填写一遍，不排除有比较懒的测试人员，看不到你的账号信息。毕竟APP一旦打回，会耽误3-4天的上线时间。</li>
<li>联系信息：填写公司产品负责人的联系方式</li>
</ul>

<h2 id="toc_37">ASO优化</h2>

<p><a href="https://www.zhihu.com/question/23027114?rf=27740130">知乎详解ASO优化</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[当虹云直播SDK植入引导]]></title>
    <link href="http://blog.csdn.net/15130871866705.html"/>
    <updated>2017-12-12T21:59:46+08:00</updated>
    <id>http://blog.csdn.net/15130871866705.html</id>
    <content type="html"><![CDATA[
<hr/>

<h2 id="toc_0">一、导入静态库 libARCPlayerRecoder.a</h2>

<h2 id="toc_1">二、导入framework</h2>

<p>(img)</p>

<h2 id="toc_2">三、添加info.plist文件的授权选项 麦克风 摄像头权限授权申请</h2>

<p>(img)</p>

<h2 id="toc_3">四、.m文件 中引用 C++方法的时候 需要变为.mm文件</h2>

<h2 id="toc_4">五、变量类型转换</h2>

<p>self 改为 (__bridge void *) self<br/>
用  (__bridge void *)  进行类型的强制转换</p>

<span id="more"></span><!-- more -->

<h1 id="toc_5">六、真机测试</h1>

<p>真机运行才可以，不支持模拟器哦</p>

]]></content>
  </entry>
  
</feed>
